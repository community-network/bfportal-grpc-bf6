// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v3.19.1
// source: play.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { CallContext, CallOptions } from "nice-grpc-common";

export const protobufPackage = "santiago.web.play";

export enum ExperienceOrderBy {
  EXPERIENCE_ORDER_BY_UNSPECIFIED = 0,
  EXPERIENCE_ORDER_BY_UPDATED_ASC = 1,
  EXPERIENCE_ORDER_BY_UPDATED_DESC = 2,
  EXPERIENCE_ORDER_BY_CREATED_ASC = 3,
  EXPERIENCE_ORDER_BY_CREATED_DESC = 4,
  EXPERIENCE_ORDER_BY_POPULARITY_ASC = 5,
  EXPERIENCE_ORDER_BY_POPULARITY_DESC = 6,
  EXPERIENCE_ORDER_BY_LIKES_ASC = 7,
  EXPERIENCE_ORDER_BY_LIKES_DESC = 8,
  UNRECOGNIZED = -1,
}

export enum InternalCapacityType {
  AI_BACKFILL = 0,
  AI_STATIC = 1,
  UNRECOGNIZED = -1,
}

export enum TeamBalancingMethod {
  UNSPECIFIED = 0,
  /** EVEN_NUMBERS - EVEN_NUMBERS - Same number of players in every team */
  EVEN_NUMBERS = 1,
  /** EVEN_PERCENTAGE - EVEN_PERCENTAGE - Same percentage of capacity in every team */
  EVEN_PERCENTAGE = 2,
  /** FILL_IN_TEAM_ORDER - FILL_IN_TEAM_ORDER - Fill lowest teamId first, then move on to second lowest, and so on... */
  FILL_IN_TEAM_ORDER = 3,
  UNRECOGNIZED = -1,
}

export enum RotationBehavior {
  /** ROTATION_BEHAVIOR_LOOP - ROTATION_BEHAVIOR_LOOP - Start the rotation over from the beginning (default) */
  ROTATION_BEHAVIOR_LOOP = 0,
  /** ROTATION_BEHAVIOR_EORMM - ROTATION_BEHAVIOR_EORMM - Rotate through the maps by using end of round matchmaking */
  ROTATION_BEHAVIOR_EORMM = 1,
  /** ROTATION_BEHAVIOR_ONE_MAP - ROTATION_BEHAVIOR_ONE_MAP - Play only one map from the rotation and leave */
  ROTATION_BEHAVIOR_ONE_MAP = 2,
  UNRECOGNIZED = -1,
}

export enum GameServerJoinabilitySettingValue {
  GAME_SERVER_JOINABILITY_SETTING_VALUE_UNSPECIFIED = 0,
  GAME_SERVER_JOINABILITY_SETTING_VALUE_ALLOWED = 1,
  GAME_SERVER_JOINABILITY_SETTING_VALUE_DISALLOWED = 2,
  UNRECOGNIZED = -1,
}

export enum BlazeGameSettingValue {
  BLAZE_GAME_SETTING_VALUE_UNSPECIFIED = 0,
  BLAZE_GAME_SETTING_VALUE_ALLOWED = 1,
  BLAZE_GAME_SETTING_VALUE_DISALLOWED = 2,
  UNRECOGNIZED = -1,
}

export enum ModerationStateType {
  MODERATION_STATE_TYPE_UNDEFINED = 0,
  MODERATION_STATE_TYPE_IN_REVIEW = 1,
  MODERATION_STATE_TYPE_APPROVED = 2,
  MODERATION_STATE_TYPE_DENIED = 3,
  UNRECOGNIZED = -1,
}

export enum PublishStateType {
  PUBLISH_STATE_TYPE_INVALID = 0,
  PUBLISH_STATE_TYPE_DRAFT = 1,
  PUBLISH_STATE_TYPE_PUBLISHED = 2,
  PUBLISH_STATE_TYPE_ARCHIVED = 3,
  /** PUBLISH_STATE_TYPE_ERROR - PUBLISH_STATE_TYPE_ERROR - Users cannot use this state to update their play element, it can be used by the backend to indicate an error state */
  PUBLISH_STATE_TYPE_ERROR = 4,
  UNRECOGNIZED = -1,
}

export enum ProcessingStatus {
  PROCESSING_STATUS_UNSPECIFIED = 0,
  /** PROCESSING_STATUS_PENDING - PROCESSING_STATUS_PENDING - Processing is in-progress */
  PROCESSING_STATUS_PENDING = 1,
  /** PROCESSING_STATUS_PROCESSED - PROCESSING_STATUS_PROCESSED - Attachment is processed and ready to use */
  PROCESSING_STATUS_PROCESSED = 2,
  /** PROCESSING_STATUS_NEEDS_RECOMPILE - PROCESSING_STATUS_NEEDS_RECOMPILE - Previously processed, but no longer valid/usable (e.g. due to version mismatch) */
  PROCESSING_STATUS_NEEDS_RECOMPILE = 3,
  /** PROCESSING_STATUS_ERROR - PROCESSING_STATUS_ERROR - An error has occurred resulting in failure to process */
  PROCESSING_STATUS_ERROR = 4,
  UNRECOGNIZED = -1,
}

export enum AttachmentCompileStatus {
  ATTACHMENT_COMPILE_STATUS_UNSPECIFIED = 0,
  ATTACHMENT_COMPILE_STATUS_OK = 1,
  ATTACHMENT_COMPILE_STATUS_ERROR = 2,
  ATTACHMENT_COMPILE_STATUS_INCOMPATIBLE_VERSION = 3,
  UNRECOGNIZED = -1,
}

export enum AttachmentType {
  ATTACHMENT_TYPE_UNSPECIFIED = 0,
  ATTACHMENT_TYPE_SPATIAL = 1,
  ATTACHMENT_TYPE_SCRIPT = 2,
  ATTACHMENT_TYPE_SCRIPT_DATA = 3,
  ATTACHMENT_TYPE_STRINGS = 4,
  ATTACHMENT_TYPE_MP_DATA = 5,
  UNRECOGNIZED = -1,
}

export enum Platform {
  UNKNOWN = 0,
  /** PC - PC - EA App */
  PC = 1,
  PS4 = 2,
  XBOXONE = 3,
  PS5 = 4,
  XBSX = 5,
  /** COMMON - COMMON - Used for requests that includes a cross-platform payload */
  COMMON = 6,
  STEAM = 7,
  UNRECOGNIZED = -1,
}

export interface DeleteAttachmentsRequest {
  playElementDesignId: string;
  attachmentIds: string[];
}

export interface DeleteAttachmentsResponse {
}

export interface GetLicenseRequirementsRequest {
}

export interface GetLicenseRequirementsResponse {
  ownedLicenses: string[];
  mapEntryRequirements: MapEntryRequirement[];
}

export interface MapEntryRequirement {
  levelName: string;
  levelLocation: string;
  licenseRequirements: string[];
}

export interface GetProgressionTypesRequest {
}

export interface GetProgressionTypesResponse {
  entries: ProgressionEntry[];
}

export interface ProgressionEntry {
  progressionMode: string;
  progressibles: Mutator[];
}

export interface UploadExperienceThumbnailRequest {
  image: Uint8Array;
  /** "image/png" */
  mimeType: string;
}

export interface UploadExperienceThumbnailResponse {
  assetId: string;
  /** Url where image is available when verification succeeds */
  url: string;
  /** Url that needs to be polled to verify upload & scan success or error */
  verificationUrl: string;
}

export interface CreateModDataVersionResponse {
  signedUrl: string;
  validUntil?: number | undefined;
  modLevelDataId: string;
}

export interface CreateModDataVersionRequest {
  playElementId: string;
}

export interface ListModDataVersionsRequest {
  playElementId: string;
}

export interface ListModDataVersionsResponse {
  modDataVersions: ModDataVersion[];
}

export interface ModDataVersion {
  id: string;
  playElementId: string;
  created?: number | undefined;
  buildInfo?: ModDataVersionBuildInfo | undefined;
}

export interface ModDataVersionBuildInfo {
  pipelineVersion: string;
  pending?: Empty | undefined;
  noBuildAvailable?: Empty | undefined;
  error?: BuildStatusError | undefined;
  success?: BuildStatusSuccess | undefined;
}

export interface BuildStatusError {
  errorMessage: string;
}

export interface BuildStatusSuccess {
}

export interface Empty {
}

export interface GetAvailableTagsRequest {
}

export interface GetAvailableTagsResponse {
  availableTags?: AvailableTags | undefined;
}

export interface PlayExperience {
  /** Coupe id */
  id: string;
  creator?:
    | Creator
    | undefined;
  /** e.g. Some Crazy nomad Conquest */
  name: string;
  /** e.g. Join the Battlefield but make sure you're always on the move because anyone standing still for more than 10 seconds gets their computer fork bombed. */
  description?: string | undefined;
  playElementDesign?:
    | PlayElementDesign
    | undefined;
  /** Will only be populated when searching experiences (i,e rpc listExperiences) */
  playerCount?: number | undefined;
  likes?:
    | number
    | undefined;
  /** if not public yet */
  publishAt?:
    | number
    | undefined;
  /** creator-selected image */
  thumbnailUrl?:
    | string
    | undefined;
  /** the creator is a regular player account */
  isUgc: boolean;
  /** short code for ugc experience */
  shortCode?:
    | string
    | undefined;
  /** DRAFT, PUBLISHED, ... */
  publishState: PublishStateType;
}

export interface ListExperiencesResponse {
  experiences: PlayExperience[];
  nextPage?: Pagination | undefined;
}

export interface PlayExperienceQuery {
  mapsEq: string[];
  levelLocationsEq: string[];
  maxPlayerCountEq: number[];
  tagsEq: string[];
  playerCreatorEq?: PlayerCreator | undefined;
  ordering: ExperienceOrderBy;
  pageSize: number;
  namePrefix?: string | undefined;
  shortCode?: string | undefined;
}

export interface ListExperiencesRequest {
  filter?: PlayExperienceQuery | undefined;
  page?: Pagination | undefined;
}

export interface Pagination {
  pageNumber?: number | undefined;
  token?: string | undefined;
}

export interface DeletePlayElementRequest {
  playElementId: string;
}

export interface GetScheduledBlueprintsResponse {
  blueprintIds: BlueprintId[];
}

export interface DeletePlayElementResponse {
}

export interface GetBlueprintsByIdRequest {
  blueprintIds: BlueprintId[];
}

export interface BlueprintId {
  id: string;
  version: string;
}

export interface GetBlueprintsByIdResponse {
  blueprints: Blueprint[];
}

export interface GetScheduledBlueprintsRequest {
}

export interface Blueprint {
  blueprintId?: BlueprintId | undefined;
  name: string;
  availableGameData?: AvailableGameData | undefined;
  availableTags?: AvailableTags | undefined;
  availableThumbnailUrls: string[];
  availableProgressionModeTags?: AvailableTags | undefined;
}

export interface AvailableGameData {
  mutators: AvailableMutator[];
  maps: AvailableMapEntry[];
  modRules?: ModRulesDefinition | undefined;
  assetCategories?: AvailableAssetCategories | undefined;
  spatialAssetInfo?: AssetInfo | undefined;
}

/**
 * entities: { [key: string]: EntityList };
 * prefabs: { [key: string]: Prefab };
 */
export interface AssetInfo {
}

export interface Prefab {
  prefabInstance: string;
  prefabPartition: string;
  prefabType: string;
  gemInstance: string;
  gemPartition: string;
  gemType: string;
}

export interface EntityList {
  entity: string[];
}

export interface AvailableAssetCategories {
  rootTags: AvailableAssetCategoryTag[];
  tags: AvailableAssetCategoryTag[];
}

export interface AvailableAssetCategoryTag {
  tagId: string;
  name: string;
  childrenTags: string[];
  metadata?: Metadata | undefined;
}

export interface ModRulesDefinition {
  rulesVersion: number;
  modBuilder: Uint8Array;
}

export interface AvailableTag {
  id: string;
  metadata?: Metadata | undefined;
  category?: string | undefined;
}

export interface AvailableMapEntry {
  levelName: string;
  levelLocation: string;
  gameSize?: AvailableIntValue | undefined;
  rounds?: AvailableIntValue | undefined;
  allowedSpectators?: AvailableIntValue | undefined;
  metadata?: Metadata | undefined;
  allowedTeamsRange?: AvailableIntValue | undefined;
}

export interface AvailableIntValue {
  defaultValue: number;
  availableValues?: AvailableIntValues | undefined;
}

export interface AvailableIntValues {
  range?: IntRange | undefined;
  sparseValues?: SparseIntValues | undefined;
}

export interface SparseIntValues {
  values: number[];
}

export interface IntRange {
  minValue: number;
  maxValue: number;
}

export interface AvailableTags {
  tags: AvailableTag[];
}

export interface AvailableMutator {
  name: string;
  category: string;
  kind?: AvailableMutatorKind | undefined;
  metadata?: Metadata | undefined;
  id: string;
}

export interface AvailableMutatorKind {
  mutatorBoolean?:
    | MutatorBoolean
    | undefined;
  /**
   * missing 2
   * missing 3
   */
  mutatorString?: MutatorString | undefined;
  mutatorFloatValues?: AvailableMutatorFloatValues | undefined;
  mutatorIntValues?: AvailableMutatorIntValues | undefined;
  mutatorSparseBoolean?: MutatorSparseBoolean | undefined;
  mutatorSparseIntValues?: AvailableMutatorSparseIntValues | undefined;
  mutatorSparseFloatValues?: AvailableMutatorSparseFloatValues | undefined;
}

export interface AvailableMutatorSparseIntValues {
  mutator?: MutatorSparseInt | undefined;
  availableValues?: AvailableIntValues | undefined;
}

export interface AvailableMutatorSparseFloatValues {
  mutator?: MutatorSparseFloat | undefined;
  availableValues?: AvailableFloatValues | undefined;
}

export interface CreatePlayElementRequest {
  name: string;
  description?: string | undefined;
  designMetadata?: DesignMetadata | undefined;
  mapRotation?: MapRotation | undefined;
  mutators: Mutator[];
  assetCategories: AssetCategory[];
  originalModRules: Uint8Array;
  playElementSettings?: PlayElementSettings | undefined;
  publishState: PublishStateType;
  modLevelDataId?: string | undefined;
  thumbnailUrl?: string | undefined;
  attachments: Attachment[];
}

export interface AvailableMutatorFloatValues {
  mutator?: MutatorFloat | undefined;
  availableValues: AvailableFloatValues | undefined;
}

export interface AvailableFloatValues {
  range?: FloatRange | undefined;
  sparseValues?: SparseFloatValues | undefined;
}

export interface SparseFloatValues {
  values: number[];
}

export interface FloatRange {
  minValue: number;
  maxValue: number;
}

export interface AvailableMutatorIntValues {
  mutator?: MutatorInt | undefined;
  availableValues?: AvailableIntValues | undefined;
}

export interface UpdatePlayElementRequest {
  id: string;
  name: string;
  description?: string | undefined;
  designMetadata?: DesignMetadata | undefined;
  mapRotation?: MapRotation | undefined;
  mutators: Mutator[];
  assetCategories: AssetCategory[];
  originalModRules: Uint8Array;
  playElementSettings?: PlayElementSettings | undefined;
  publishState: PublishStateType;
  modLevelDataId?: string | undefined;
  thumbnailUrl?: string | undefined;
  attachments: Attachment[];
}

export interface PlayElementResponse {
  playElement?: PlayElement | undefined;
  playElementDesign?: PlayElementDesign | undefined;
  progressionMode?: string | undefined;
}

export interface PlayElement {
  id: string;
  designId: string;
  creator?: Creator | undefined;
  name: string;
  description?: string | undefined;
  created?: number | undefined;
  updated?: number | undefined;
  playElementSettings?: PlayElementSettings | undefined;
  publishStateType: PublishStateType;
  likes?:
    | number
    | undefined;
  /** if not public yet */
  publishAt?: number | undefined;
  thumbnailUrl?:
    | string
    | undefined;
  /** Fan Care status */
  moderationState: ModerationStateType;
  shortCode?: string | undefined;
}

export interface PlayElementDesign {
  designId: string;
  designName: string;
  /** missing 3 */
  updated?: number | undefined;
  designMetadata?: DesignMetadata | undefined;
  mapRotation?: MapRotation | undefined;
  mutators: Mutator[];
  assetCategories: AssetCategory[];
  licenseRequirements: string[];
  modRules?: ModRules | undefined;
  tags: Tag[];
  blazeSettings?: BlazePlayElementDesignSettings | undefined;
  modLevelDataId?: string | undefined;
  attachments: Attachment[];
  groupLicenses: string[];
  attachmentCompileStatus: AttachmentCompileStatus;
  /** required licenses to host experience, in addition to `license_requirements` */
  serverHostLicenseRequirements: string[];
}

export interface Creator {
  internalCreator?: InternalCreator | undefined;
  playerCreator?: PlayerCreator | undefined;
  externalCreator?: ExternalCreator | undefined;
  trustedCreator?: PlayerCreator | undefined;
}

export interface InternalCreator {
}

export interface PlayerCreator {
  player?: Player | undefined;
}

export interface ExternalCreator {
}

export interface Player {
  nucleusId: number;
  personaId: number;
  platform: Platform;
}

export interface Tag {
  tagId: string;
  priority: number;
  metadata?: Metadata | undefined;
}

export interface Metadata {
  translations: TranslationMetadata[];
  resources: Resource[];
}

export interface TranslationMetadata {
  kind: string;
  translationId: string;
}

export interface Resource {
  location?: ResourceLocation | undefined;
  kind: string;
}

export interface ResourceLocation {
  ref?: string | undefined;
  url?: string | undefined;
}

export interface Attachment {
  /** guid */
  id: string;
  /** n.b. version string may have a different meaning or format depending on type of attachment. */
  version: string;
  filename?:
    | string
    | undefined;
  /** Means "this must go through some compilation/transformation to be usable". If false, the "original" variant can be used directly */
  isProcessable: boolean;
  processingStatus: ProcessingStatus;
  attachmentData?: AttachmentData | undefined;
  attachmentType: AttachmentType;
  /** place to put stuff like map rotation index -- misc future-proofing.  Format TBD, maybe CSV or queryParam format like MapEntry metadata */
  metadata?: string | undefined;
  errors: string[];
}

export interface PlayElementSettings {
  secret?: string | undefined;
  messages: GameServerMessage[];
  /** creator has allowed copying experience underlying data */
  allowCopies: boolean;
}

export interface GameServerMessage {
  kind: string;
  text: string;
}

export interface DesignMetadata {
  progressionMode?: string | undefined;
  firstPartyMetadata: FirstPartyMetadata[];
}

export interface FirstPartyMetadata {
  psnMetadata?: PSNMetadata | undefined;
}

export interface PSNMetadata {
  activityId: string;
}

export interface MapRotation {
  maps: MapEntry[];
  attributes?: MapRotationAttributes | undefined;
}

export interface MapEntry {
  levelName: string;
  levelLocation: string;
  rounds: number;
  allowedSpectators: number;
  teamComposition?: TeamComposition | undefined;
  blazeGameSettings?: BlazeGameSettings | undefined;
  mutators: Mutator[];
  gameServerJoinabilitySettings?: GameServerJoinabilitySettings | undefined;
}

export interface BlazeGameSettings {
  /** can/will be extended with more options */
  joinInProgress: BlazeGameSettingValue;
  /** whether the game can be joined by joining on a player id (join on a friend) */
  openToJoinByPlayer: BlazeGameSettingValue;
  /** whether the game can be joined by accepting a friend invite */
  openToInvites: BlazeGameSettingValue;
}

export interface GameServerJoinabilitySettings {
  /** whether the game can be joined via matchmaking after it leaves PRE_GAME */
  matchmakingInProgress: GameServerJoinabilitySettingValue;
}

export interface MapRotationAttributes {
  rotationBehavior: RotationBehavior;
}

export interface ModRules {
  compatibleRules?: CompatibleModRules | undefined;
  incompatibleRules?: IncompatibleModRules | undefined;
  errorRules?: ErrorModRules | undefined;
}

export interface BlazePlayElementDesignSettings {
  openGroupReservations: BlazeGameSettingValue;
}

export interface AttachmentData {
  original: Uint8Array;
  /** If "compiled" is present, we can use it as-is (don't re-compile).  Webapp should omit/clear the "compiled" if the user replaces/edits an attachment. */
  compiled?: Uint8Array | undefined;
}

export interface TeamComposition {
  teams: TeamStructure[];
  internalTeams: InternalTeamStructure[];
  balancingMethod: TeamBalancingMethod;
}

export interface TeamStructure {
  /** Team number */
  teamId: number;
  /** Number of slots */
  capacity: number;
}

export interface InternalTeamStructure {
  /** Team number */
  teamId: number;
  /** Number of slots */
  capacity: number;
  capacityType: InternalCapacityType;
}

export interface CompatibleModRules {
  original: Uint8Array;
  rulesVersion: number;
  compiled?: CompiledRules | undefined;
}

export interface CompiledRules {
  uncompressed?: Uncompressed | undefined;
  compressed?: Compressed | undefined;
}

export interface Uncompressed {
  compiledModRules: Uint8Array;
  rulesVersion: number;
}

export interface Compressed {
  compiledModRules: Uint8Array;
  rulesVersion: number;
  inflatedSize: number;
}

export interface IncompatibleModRules {
  original: Uint8Array;
  rulesVersion: number;
  blueprintRulesVersion: number;
}

export interface ErrorModRules {
  original: Uint8Array;
  errorMessage?: string | undefined;
}

export interface AssetCategory {
  tagId: string;
  boolean?: AssetCategoryBoolean | undefined;
}

export interface AssetCategoryBoolean {
  /** All mutators belonging the the category will have this value, unless overriden */
  defaultValue: boolean;
  overrides?:
    | AssetCategoryTagBooleanOverride
    | undefined;
  /** One entry per team */
  teamOverrides: AssetCategoryTagBooleanTeamOverride[];
}

export interface AssetCategoryTagBooleanOverride {
  assetCategoryTags: string[];
  value: boolean;
}

export interface AssetCategoryTagBooleanTeamOverride {
  assetCategoryTags: string[];
  value: boolean;
  teamId: number;
}

export interface Mutator {
  name: string;
  category: string;
  kind?: MutatorKind | undefined;
  id: string;
}

export interface MutatorKind {
  mutatorBoolean?: MutatorBoolean | undefined;
  mutatorString?: MutatorString | undefined;
  mutatorFloat?: MutatorFloat | undefined;
  mutatorInt?: MutatorInt | undefined;
  mutatorSparseBoolean?: MutatorSparseBoolean | undefined;
  mutatorSparseInt?: MutatorSparseInt | undefined;
  mutatorSparseFloat?: MutatorSparseFloat | undefined;
}

export interface MutatorBoolean {
  boolValue: boolean;
}

export interface MutatorString {
  stringValue: string;
}

export interface MutatorFloat {
  value: number;
}

export interface MutatorInt {
  value: number;
}

export interface MutatorSparseBooleanEntry {
  index: number;
  value: boolean;
}

export interface MutatorSparseBoolean {
  defaultValue: boolean;
  size: number;
  sparseValues: MutatorSparseBooleanEntry[];
}

export interface SparseIntEntity {
  values: number[];
}

export interface MutatorSparseIntEntry {
  index: number;
  value: number;
}

export interface MutatorSparseInt {
  defaultValue: number;
  size: number;
  sparseValues: MutatorSparseIntEntry | undefined;
}

export interface MutatorSparseFloatEntry {
  index: number;
  value: number;
}

export interface MutatorSparseFloat {
  defaultValue: number;
  size: number;
  sparseValues: MutatorSparseFloatEntry[];
}

export interface GetPlayElementRequest {
  id: string;
  /** Include experiences hidden by Fan Care */
  includeDenied: boolean;
}

export interface GetOwnedPlayElementsResponse {
  playElements: PlayElement[];
}

export interface GetOwnedPlayElementsResponseV2 {
  playElements: EnrichedPlayElement[];
}

export interface EnrichedPlayElement {
  playElement?: PlayElement | undefined;
  mapRotation?: MapRotation | undefined;
}

export interface GetOwnedPlayElementsRequest {
  publishStates: PublishStateType[];
  /** Include experiences hidden by Fan Care */
  includeDenied: boolean;
}

function createBaseDeleteAttachmentsRequest(): DeleteAttachmentsRequest {
  return { playElementDesignId: "", attachmentIds: [] };
}

export const DeleteAttachmentsRequest: MessageFns<DeleteAttachmentsRequest> = {
  encode(message: DeleteAttachmentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playElementDesignId !== "") {
      writer.uint32(10).string(message.playElementDesignId);
    }
    for (const v of message.attachmentIds) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAttachmentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAttachmentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playElementDesignId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.attachmentIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<DeleteAttachmentsRequest>): DeleteAttachmentsRequest {
    return DeleteAttachmentsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteAttachmentsRequest>): DeleteAttachmentsRequest {
    const message = createBaseDeleteAttachmentsRequest();
    message.playElementDesignId = object.playElementDesignId ?? "";
    message.attachmentIds = object.attachmentIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseDeleteAttachmentsResponse(): DeleteAttachmentsResponse {
  return {};
}

export const DeleteAttachmentsResponse: MessageFns<DeleteAttachmentsResponse> = {
  encode(_: DeleteAttachmentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAttachmentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAttachmentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<DeleteAttachmentsResponse>): DeleteAttachmentsResponse {
    return DeleteAttachmentsResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<DeleteAttachmentsResponse>): DeleteAttachmentsResponse {
    const message = createBaseDeleteAttachmentsResponse();
    return message;
  },
};

function createBaseGetLicenseRequirementsRequest(): GetLicenseRequirementsRequest {
  return {};
}

export const GetLicenseRequirementsRequest: MessageFns<GetLicenseRequirementsRequest> = {
  encode(_: GetLicenseRequirementsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLicenseRequirementsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLicenseRequirementsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetLicenseRequirementsRequest>): GetLicenseRequirementsRequest {
    return GetLicenseRequirementsRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GetLicenseRequirementsRequest>): GetLicenseRequirementsRequest {
    const message = createBaseGetLicenseRequirementsRequest();
    return message;
  },
};

function createBaseGetLicenseRequirementsResponse(): GetLicenseRequirementsResponse {
  return { ownedLicenses: [], mapEntryRequirements: [] };
}

export const GetLicenseRequirementsResponse: MessageFns<GetLicenseRequirementsResponse> = {
  encode(message: GetLicenseRequirementsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ownedLicenses) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.mapEntryRequirements) {
      MapEntryRequirement.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLicenseRequirementsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLicenseRequirementsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ownedLicenses.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mapEntryRequirements.push(MapEntryRequirement.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetLicenseRequirementsResponse>): GetLicenseRequirementsResponse {
    return GetLicenseRequirementsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetLicenseRequirementsResponse>): GetLicenseRequirementsResponse {
    const message = createBaseGetLicenseRequirementsResponse();
    message.ownedLicenses = object.ownedLicenses?.map((e) => e) || [];
    message.mapEntryRequirements = object.mapEntryRequirements?.map((e) => MapEntryRequirement.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMapEntryRequirement(): MapEntryRequirement {
  return { levelName: "", levelLocation: "", licenseRequirements: [] };
}

export const MapEntryRequirement: MessageFns<MapEntryRequirement> = {
  encode(message: MapEntryRequirement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.levelName !== "") {
      writer.uint32(10).string(message.levelName);
    }
    if (message.levelLocation !== "") {
      writer.uint32(18).string(message.levelLocation);
    }
    for (const v of message.licenseRequirements) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapEntryRequirement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapEntryRequirement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.levelName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.levelLocation = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.licenseRequirements.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<MapEntryRequirement>): MapEntryRequirement {
    return MapEntryRequirement.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapEntryRequirement>): MapEntryRequirement {
    const message = createBaseMapEntryRequirement();
    message.levelName = object.levelName ?? "";
    message.levelLocation = object.levelLocation ?? "";
    message.licenseRequirements = object.licenseRequirements?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetProgressionTypesRequest(): GetProgressionTypesRequest {
  return {};
}

export const GetProgressionTypesRequest: MessageFns<GetProgressionTypesRequest> = {
  encode(_: GetProgressionTypesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProgressionTypesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProgressionTypesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetProgressionTypesRequest>): GetProgressionTypesRequest {
    return GetProgressionTypesRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GetProgressionTypesRequest>): GetProgressionTypesRequest {
    const message = createBaseGetProgressionTypesRequest();
    return message;
  },
};

function createBaseGetProgressionTypesResponse(): GetProgressionTypesResponse {
  return { entries: [] };
}

export const GetProgressionTypesResponse: MessageFns<GetProgressionTypesResponse> = {
  encode(message: GetProgressionTypesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entries) {
      ProgressionEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProgressionTypesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProgressionTypesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entries.push(ProgressionEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetProgressionTypesResponse>): GetProgressionTypesResponse {
    return GetProgressionTypesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetProgressionTypesResponse>): GetProgressionTypesResponse {
    const message = createBaseGetProgressionTypesResponse();
    message.entries = object.entries?.map((e) => ProgressionEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProgressionEntry(): ProgressionEntry {
  return { progressionMode: "", progressibles: [] };
}

export const ProgressionEntry: MessageFns<ProgressionEntry> = {
  encode(message: ProgressionEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.progressionMode !== "") {
      writer.uint32(10).string(message.progressionMode);
    }
    for (const v of message.progressibles) {
      Mutator.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProgressionEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProgressionEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.progressionMode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.progressibles.push(Mutator.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ProgressionEntry>): ProgressionEntry {
    return ProgressionEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProgressionEntry>): ProgressionEntry {
    const message = createBaseProgressionEntry();
    message.progressionMode = object.progressionMode ?? "";
    message.progressibles = object.progressibles?.map((e) => Mutator.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUploadExperienceThumbnailRequest(): UploadExperienceThumbnailRequest {
  return { image: new Uint8Array(0), mimeType: "" };
}

export const UploadExperienceThumbnailRequest: MessageFns<UploadExperienceThumbnailRequest> = {
  encode(message: UploadExperienceThumbnailRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.image.length !== 0) {
      writer.uint32(10).bytes(message.image);
    }
    if (message.mimeType !== "") {
      writer.uint32(18).string(message.mimeType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadExperienceThumbnailRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadExperienceThumbnailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.image = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<UploadExperienceThumbnailRequest>): UploadExperienceThumbnailRequest {
    return UploadExperienceThumbnailRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UploadExperienceThumbnailRequest>): UploadExperienceThumbnailRequest {
    const message = createBaseUploadExperienceThumbnailRequest();
    message.image = object.image ?? new Uint8Array(0);
    message.mimeType = object.mimeType ?? "";
    return message;
  },
};

function createBaseUploadExperienceThumbnailResponse(): UploadExperienceThumbnailResponse {
  return { assetId: "", url: "", verificationUrl: "" };
}

export const UploadExperienceThumbnailResponse: MessageFns<UploadExperienceThumbnailResponse> = {
  encode(message: UploadExperienceThumbnailResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.assetId !== "") {
      writer.uint32(10).string(message.assetId);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    if (message.verificationUrl !== "") {
      writer.uint32(26).string(message.verificationUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadExperienceThumbnailResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadExperienceThumbnailResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.assetId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.verificationUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<UploadExperienceThumbnailResponse>): UploadExperienceThumbnailResponse {
    return UploadExperienceThumbnailResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UploadExperienceThumbnailResponse>): UploadExperienceThumbnailResponse {
    const message = createBaseUploadExperienceThumbnailResponse();
    message.assetId = object.assetId ?? "";
    message.url = object.url ?? "";
    message.verificationUrl = object.verificationUrl ?? "";
    return message;
  },
};

function createBaseCreateModDataVersionResponse(): CreateModDataVersionResponse {
  return { signedUrl: "", validUntil: undefined, modLevelDataId: "" };
}

export const CreateModDataVersionResponse: MessageFns<CreateModDataVersionResponse> = {
  encode(message: CreateModDataVersionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signedUrl !== "") {
      writer.uint32(10).string(message.signedUrl);
    }
    if (message.validUntil !== undefined) {
      writer.uint32(16).uint32(message.validUntil);
    }
    if (message.modLevelDataId !== "") {
      writer.uint32(26).string(message.modLevelDataId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateModDataVersionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateModDataVersionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signedUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.validUntil = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.modLevelDataId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<CreateModDataVersionResponse>): CreateModDataVersionResponse {
    return CreateModDataVersionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateModDataVersionResponse>): CreateModDataVersionResponse {
    const message = createBaseCreateModDataVersionResponse();
    message.signedUrl = object.signedUrl ?? "";
    message.validUntil = object.validUntil ?? undefined;
    message.modLevelDataId = object.modLevelDataId ?? "";
    return message;
  },
};

function createBaseCreateModDataVersionRequest(): CreateModDataVersionRequest {
  return { playElementId: "" };
}

export const CreateModDataVersionRequest: MessageFns<CreateModDataVersionRequest> = {
  encode(message: CreateModDataVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playElementId !== "") {
      writer.uint32(10).string(message.playElementId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateModDataVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateModDataVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playElementId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<CreateModDataVersionRequest>): CreateModDataVersionRequest {
    return CreateModDataVersionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateModDataVersionRequest>): CreateModDataVersionRequest {
    const message = createBaseCreateModDataVersionRequest();
    message.playElementId = object.playElementId ?? "";
    return message;
  },
};

function createBaseListModDataVersionsRequest(): ListModDataVersionsRequest {
  return { playElementId: "" };
}

export const ListModDataVersionsRequest: MessageFns<ListModDataVersionsRequest> = {
  encode(message: ListModDataVersionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playElementId !== "") {
      writer.uint32(10).string(message.playElementId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListModDataVersionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListModDataVersionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playElementId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ListModDataVersionsRequest>): ListModDataVersionsRequest {
    return ListModDataVersionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListModDataVersionsRequest>): ListModDataVersionsRequest {
    const message = createBaseListModDataVersionsRequest();
    message.playElementId = object.playElementId ?? "";
    return message;
  },
};

function createBaseListModDataVersionsResponse(): ListModDataVersionsResponse {
  return { modDataVersions: [] };
}

export const ListModDataVersionsResponse: MessageFns<ListModDataVersionsResponse> = {
  encode(message: ListModDataVersionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.modDataVersions) {
      ModDataVersion.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListModDataVersionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListModDataVersionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.modDataVersions.push(ModDataVersion.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ListModDataVersionsResponse>): ListModDataVersionsResponse {
    return ListModDataVersionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListModDataVersionsResponse>): ListModDataVersionsResponse {
    const message = createBaseListModDataVersionsResponse();
    message.modDataVersions = object.modDataVersions?.map((e) => ModDataVersion.fromPartial(e)) || [];
    return message;
  },
};

function createBaseModDataVersion(): ModDataVersion {
  return { id: "", playElementId: "", created: undefined, buildInfo: undefined };
}

export const ModDataVersion: MessageFns<ModDataVersion> = {
  encode(message: ModDataVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.playElementId !== "") {
      writer.uint32(18).string(message.playElementId);
    }
    if (message.created !== undefined) {
      writer.uint32(24).uint32(message.created);
    }
    if (message.buildInfo !== undefined) {
      ModDataVersionBuildInfo.encode(message.buildInfo, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModDataVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModDataVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.playElementId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.created = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.buildInfo = ModDataVersionBuildInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ModDataVersion>): ModDataVersion {
    return ModDataVersion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ModDataVersion>): ModDataVersion {
    const message = createBaseModDataVersion();
    message.id = object.id ?? "";
    message.playElementId = object.playElementId ?? "";
    message.created = object.created ?? undefined;
    message.buildInfo = (object.buildInfo !== undefined && object.buildInfo !== null)
      ? ModDataVersionBuildInfo.fromPartial(object.buildInfo)
      : undefined;
    return message;
  },
};

function createBaseModDataVersionBuildInfo(): ModDataVersionBuildInfo {
  return { pipelineVersion: "", pending: undefined, noBuildAvailable: undefined, error: undefined, success: undefined };
}

export const ModDataVersionBuildInfo: MessageFns<ModDataVersionBuildInfo> = {
  encode(message: ModDataVersionBuildInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pipelineVersion !== "") {
      writer.uint32(10).string(message.pipelineVersion);
    }
    if (message.pending !== undefined) {
      Empty.encode(message.pending, writer.uint32(18).fork()).join();
    }
    if (message.noBuildAvailable !== undefined) {
      Empty.encode(message.noBuildAvailable, writer.uint32(26).fork()).join();
    }
    if (message.error !== undefined) {
      BuildStatusError.encode(message.error, writer.uint32(34).fork()).join();
    }
    if (message.success !== undefined) {
      BuildStatusSuccess.encode(message.success, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModDataVersionBuildInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModDataVersionBuildInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pipelineVersion = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pending = Empty.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.noBuildAvailable = Empty.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = BuildStatusError.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.success = BuildStatusSuccess.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ModDataVersionBuildInfo>): ModDataVersionBuildInfo {
    return ModDataVersionBuildInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ModDataVersionBuildInfo>): ModDataVersionBuildInfo {
    const message = createBaseModDataVersionBuildInfo();
    message.pipelineVersion = object.pipelineVersion ?? "";
    message.pending = (object.pending !== undefined && object.pending !== null)
      ? Empty.fromPartial(object.pending)
      : undefined;
    message.noBuildAvailable = (object.noBuildAvailable !== undefined && object.noBuildAvailable !== null)
      ? Empty.fromPartial(object.noBuildAvailable)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? BuildStatusError.fromPartial(object.error)
      : undefined;
    message.success = (object.success !== undefined && object.success !== null)
      ? BuildStatusSuccess.fromPartial(object.success)
      : undefined;
    return message;
  },
};

function createBaseBuildStatusError(): BuildStatusError {
  return { errorMessage: "" };
}

export const BuildStatusError: MessageFns<BuildStatusError> = {
  encode(message: BuildStatusError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.errorMessage !== "") {
      writer.uint32(10).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildStatusError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildStatusError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<BuildStatusError>): BuildStatusError {
    return BuildStatusError.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BuildStatusError>): BuildStatusError {
    const message = createBaseBuildStatusError();
    message.errorMessage = object.errorMessage ?? "";
    return message;
  },
};

function createBaseBuildStatusSuccess(): BuildStatusSuccess {
  return {};
}

export const BuildStatusSuccess: MessageFns<BuildStatusSuccess> = {
  encode(_: BuildStatusSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildStatusSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildStatusSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<BuildStatusSuccess>): BuildStatusSuccess {
    return BuildStatusSuccess.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<BuildStatusSuccess>): BuildStatusSuccess {
    const message = createBaseBuildStatusSuccess();
    return message;
  },
};

function createBaseEmpty(): Empty {
  return {};
}

export const Empty: MessageFns<Empty> = {
  encode(_: Empty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Empty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Empty>): Empty {
    return Empty.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Empty>): Empty {
    const message = createBaseEmpty();
    return message;
  },
};

function createBaseGetAvailableTagsRequest(): GetAvailableTagsRequest {
  return {};
}

export const GetAvailableTagsRequest: MessageFns<GetAvailableTagsRequest> = {
  encode(_: GetAvailableTagsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAvailableTagsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAvailableTagsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetAvailableTagsRequest>): GetAvailableTagsRequest {
    return GetAvailableTagsRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GetAvailableTagsRequest>): GetAvailableTagsRequest {
    const message = createBaseGetAvailableTagsRequest();
    return message;
  },
};

function createBaseGetAvailableTagsResponse(): GetAvailableTagsResponse {
  return { availableTags: undefined };
}

export const GetAvailableTagsResponse: MessageFns<GetAvailableTagsResponse> = {
  encode(message: GetAvailableTagsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.availableTags !== undefined) {
      AvailableTags.encode(message.availableTags, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAvailableTagsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAvailableTagsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.availableTags = AvailableTags.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetAvailableTagsResponse>): GetAvailableTagsResponse {
    return GetAvailableTagsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAvailableTagsResponse>): GetAvailableTagsResponse {
    const message = createBaseGetAvailableTagsResponse();
    message.availableTags = (object.availableTags !== undefined && object.availableTags !== null)
      ? AvailableTags.fromPartial(object.availableTags)
      : undefined;
    return message;
  },
};

function createBasePlayExperience(): PlayExperience {
  return {
    id: "",
    creator: undefined,
    name: "",
    description: undefined,
    playElementDesign: undefined,
    playerCount: undefined,
    likes: undefined,
    publishAt: undefined,
    thumbnailUrl: undefined,
    isUgc: false,
    shortCode: undefined,
    publishState: 0,
  };
}

export const PlayExperience: MessageFns<PlayExperience> = {
  encode(message: PlayExperience, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.creator !== undefined) {
      Creator.encode(message.creator, writer.uint32(18).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.description !== undefined) {
      writer.uint32(34).string(message.description);
    }
    if (message.playElementDesign !== undefined) {
      PlayElementDesign.encode(message.playElementDesign, writer.uint32(42).fork()).join();
    }
    if (message.playerCount !== undefined) {
      writer.uint32(48).int32(message.playerCount);
    }
    if (message.likes !== undefined) {
      writer.uint32(56).int32(message.likes);
    }
    if (message.publishAt !== undefined) {
      writer.uint32(64).uint32(message.publishAt);
    }
    if (message.thumbnailUrl !== undefined) {
      writer.uint32(74).string(message.thumbnailUrl);
    }
    if (message.isUgc !== false) {
      writer.uint32(80).bool(message.isUgc);
    }
    if (message.shortCode !== undefined) {
      writer.uint32(90).string(message.shortCode);
    }
    if (message.publishState !== 0) {
      writer.uint32(96).int32(message.publishState);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayExperience {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayExperience();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.creator = Creator.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.playElementDesign = PlayElementDesign.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.playerCount = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.likes = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.publishAt = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.thumbnailUrl = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.isUgc = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.shortCode = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.publishState = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PlayExperience>): PlayExperience {
    return PlayExperience.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlayExperience>): PlayExperience {
    const message = createBasePlayExperience();
    message.id = object.id ?? "";
    message.creator = (object.creator !== undefined && object.creator !== null)
      ? Creator.fromPartial(object.creator)
      : undefined;
    message.name = object.name ?? "";
    message.description = object.description ?? undefined;
    message.playElementDesign = (object.playElementDesign !== undefined && object.playElementDesign !== null)
      ? PlayElementDesign.fromPartial(object.playElementDesign)
      : undefined;
    message.playerCount = object.playerCount ?? undefined;
    message.likes = object.likes ?? undefined;
    message.publishAt = object.publishAt ?? undefined;
    message.thumbnailUrl = object.thumbnailUrl ?? undefined;
    message.isUgc = object.isUgc ?? false;
    message.shortCode = object.shortCode ?? undefined;
    message.publishState = object.publishState ?? 0;
    return message;
  },
};

function createBaseListExperiencesResponse(): ListExperiencesResponse {
  return { experiences: [], nextPage: undefined };
}

export const ListExperiencesResponse: MessageFns<ListExperiencesResponse> = {
  encode(message: ListExperiencesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.experiences) {
      PlayExperience.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPage !== undefined) {
      Pagination.encode(message.nextPage, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListExperiencesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListExperiencesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.experiences.push(PlayExperience.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPage = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ListExperiencesResponse>): ListExperiencesResponse {
    return ListExperiencesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListExperiencesResponse>): ListExperiencesResponse {
    const message = createBaseListExperiencesResponse();
    message.experiences = object.experiences?.map((e) => PlayExperience.fromPartial(e)) || [];
    message.nextPage = (object.nextPage !== undefined && object.nextPage !== null)
      ? Pagination.fromPartial(object.nextPage)
      : undefined;
    return message;
  },
};

function createBasePlayExperienceQuery(): PlayExperienceQuery {
  return {
    mapsEq: [],
    levelLocationsEq: [],
    maxPlayerCountEq: [],
    tagsEq: [],
    playerCreatorEq: undefined,
    ordering: 0,
    pageSize: 0,
    namePrefix: undefined,
    shortCode: undefined,
  };
}

export const PlayExperienceQuery: MessageFns<PlayExperienceQuery> = {
  encode(message: PlayExperienceQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.mapsEq) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.levelLocationsEq) {
      writer.uint32(18).string(v!);
    }
    writer.uint32(26).fork();
    for (const v of message.maxPlayerCountEq) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.tagsEq) {
      writer.uint32(34).string(v!);
    }
    if (message.playerCreatorEq !== undefined) {
      PlayerCreator.encode(message.playerCreatorEq, writer.uint32(42).fork()).join();
    }
    if (message.ordering !== 0) {
      writer.uint32(48).int32(message.ordering);
    }
    if (message.pageSize !== 0) {
      writer.uint32(56).int32(message.pageSize);
    }
    if (message.namePrefix !== undefined) {
      writer.uint32(66).string(message.namePrefix);
    }
    if (message.shortCode !== undefined) {
      writer.uint32(74).string(message.shortCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayExperienceQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayExperienceQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mapsEq.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.levelLocationsEq.push(reader.string());
          continue;
        }
        case 3: {
          if (tag === 24) {
            message.maxPlayerCountEq.push(reader.int32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.maxPlayerCountEq.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tagsEq.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.playerCreatorEq = PlayerCreator.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.ordering = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.namePrefix = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.shortCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PlayExperienceQuery>): PlayExperienceQuery {
    return PlayExperienceQuery.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlayExperienceQuery>): PlayExperienceQuery {
    const message = createBasePlayExperienceQuery();
    message.mapsEq = object.mapsEq?.map((e) => e) || [];
    message.levelLocationsEq = object.levelLocationsEq?.map((e) => e) || [];
    message.maxPlayerCountEq = object.maxPlayerCountEq?.map((e) => e) || [];
    message.tagsEq = object.tagsEq?.map((e) => e) || [];
    message.playerCreatorEq = (object.playerCreatorEq !== undefined && object.playerCreatorEq !== null)
      ? PlayerCreator.fromPartial(object.playerCreatorEq)
      : undefined;
    message.ordering = object.ordering ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.namePrefix = object.namePrefix ?? undefined;
    message.shortCode = object.shortCode ?? undefined;
    return message;
  },
};

function createBaseListExperiencesRequest(): ListExperiencesRequest {
  return { filter: undefined, page: undefined };
}

export const ListExperiencesRequest: MessageFns<ListExperiencesRequest> = {
  encode(message: ListExperiencesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filter !== undefined) {
      PlayExperienceQuery.encode(message.filter, writer.uint32(10).fork()).join();
    }
    if (message.page !== undefined) {
      Pagination.encode(message.page, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListExperiencesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListExperiencesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filter = PlayExperienceQuery.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.page = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ListExperiencesRequest>): ListExperiencesRequest {
    return ListExperiencesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListExperiencesRequest>): ListExperiencesRequest {
    const message = createBaseListExperiencesRequest();
    message.filter = (object.filter !== undefined && object.filter !== null)
      ? PlayExperienceQuery.fromPartial(object.filter)
      : undefined;
    message.page = (object.page !== undefined && object.page !== null)
      ? Pagination.fromPartial(object.page)
      : undefined;
    return message;
  },
};

function createBasePagination(): Pagination {
  return { pageNumber: undefined, token: undefined };
}

export const Pagination: MessageFns<Pagination> = {
  encode(message: Pagination, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageNumber !== undefined) {
      writer.uint32(8).int32(message.pageNumber);
    }
    if (message.token !== undefined) {
      writer.uint32(18).string(message.token);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pagination {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePagination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pageNumber = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.token = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Pagination>): Pagination {
    return Pagination.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Pagination>): Pagination {
    const message = createBasePagination();
    message.pageNumber = object.pageNumber ?? undefined;
    message.token = object.token ?? undefined;
    return message;
  },
};

function createBaseDeletePlayElementRequest(): DeletePlayElementRequest {
  return { playElementId: "" };
}

export const DeletePlayElementRequest: MessageFns<DeletePlayElementRequest> = {
  encode(message: DeletePlayElementRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playElementId !== "") {
      writer.uint32(10).string(message.playElementId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeletePlayElementRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeletePlayElementRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playElementId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<DeletePlayElementRequest>): DeletePlayElementRequest {
    return DeletePlayElementRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeletePlayElementRequest>): DeletePlayElementRequest {
    const message = createBaseDeletePlayElementRequest();
    message.playElementId = object.playElementId ?? "";
    return message;
  },
};

function createBaseGetScheduledBlueprintsResponse(): GetScheduledBlueprintsResponse {
  return { blueprintIds: [] };
}

export const GetScheduledBlueprintsResponse: MessageFns<GetScheduledBlueprintsResponse> = {
  encode(message: GetScheduledBlueprintsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.blueprintIds) {
      BlueprintId.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetScheduledBlueprintsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetScheduledBlueprintsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blueprintIds.push(BlueprintId.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetScheduledBlueprintsResponse>): GetScheduledBlueprintsResponse {
    return GetScheduledBlueprintsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetScheduledBlueprintsResponse>): GetScheduledBlueprintsResponse {
    const message = createBaseGetScheduledBlueprintsResponse();
    message.blueprintIds = object.blueprintIds?.map((e) => BlueprintId.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeletePlayElementResponse(): DeletePlayElementResponse {
  return {};
}

export const DeletePlayElementResponse: MessageFns<DeletePlayElementResponse> = {
  encode(_: DeletePlayElementResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeletePlayElementResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeletePlayElementResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<DeletePlayElementResponse>): DeletePlayElementResponse {
    return DeletePlayElementResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<DeletePlayElementResponse>): DeletePlayElementResponse {
    const message = createBaseDeletePlayElementResponse();
    return message;
  },
};

function createBaseGetBlueprintsByIdRequest(): GetBlueprintsByIdRequest {
  return { blueprintIds: [] };
}

export const GetBlueprintsByIdRequest: MessageFns<GetBlueprintsByIdRequest> = {
  encode(message: GetBlueprintsByIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.blueprintIds) {
      BlueprintId.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBlueprintsByIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBlueprintsByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blueprintIds.push(BlueprintId.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetBlueprintsByIdRequest>): GetBlueprintsByIdRequest {
    return GetBlueprintsByIdRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBlueprintsByIdRequest>): GetBlueprintsByIdRequest {
    const message = createBaseGetBlueprintsByIdRequest();
    message.blueprintIds = object.blueprintIds?.map((e) => BlueprintId.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBlueprintId(): BlueprintId {
  return { id: "", version: "" };
}

export const BlueprintId: MessageFns<BlueprintId> = {
  encode(message: BlueprintId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlueprintId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlueprintId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<BlueprintId>): BlueprintId {
    return BlueprintId.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlueprintId>): BlueprintId {
    const message = createBaseBlueprintId();
    message.id = object.id ?? "";
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseGetBlueprintsByIdResponse(): GetBlueprintsByIdResponse {
  return { blueprints: [] };
}

export const GetBlueprintsByIdResponse: MessageFns<GetBlueprintsByIdResponse> = {
  encode(message: GetBlueprintsByIdResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.blueprints) {
      Blueprint.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBlueprintsByIdResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBlueprintsByIdResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blueprints.push(Blueprint.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetBlueprintsByIdResponse>): GetBlueprintsByIdResponse {
    return GetBlueprintsByIdResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBlueprintsByIdResponse>): GetBlueprintsByIdResponse {
    const message = createBaseGetBlueprintsByIdResponse();
    message.blueprints = object.blueprints?.map((e) => Blueprint.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetScheduledBlueprintsRequest(): GetScheduledBlueprintsRequest {
  return {};
}

export const GetScheduledBlueprintsRequest: MessageFns<GetScheduledBlueprintsRequest> = {
  encode(_: GetScheduledBlueprintsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetScheduledBlueprintsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetScheduledBlueprintsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetScheduledBlueprintsRequest>): GetScheduledBlueprintsRequest {
    return GetScheduledBlueprintsRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GetScheduledBlueprintsRequest>): GetScheduledBlueprintsRequest {
    const message = createBaseGetScheduledBlueprintsRequest();
    return message;
  },
};

function createBaseBlueprint(): Blueprint {
  return {
    blueprintId: undefined,
    name: "",
    availableGameData: undefined,
    availableTags: undefined,
    availableThumbnailUrls: [],
    availableProgressionModeTags: undefined,
  };
}

export const Blueprint: MessageFns<Blueprint> = {
  encode(message: Blueprint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blueprintId !== undefined) {
      BlueprintId.encode(message.blueprintId, writer.uint32(10).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.availableGameData !== undefined) {
      AvailableGameData.encode(message.availableGameData, writer.uint32(26).fork()).join();
    }
    if (message.availableTags !== undefined) {
      AvailableTags.encode(message.availableTags, writer.uint32(34).fork()).join();
    }
    for (const v of message.availableThumbnailUrls) {
      writer.uint32(42).string(v!);
    }
    if (message.availableProgressionModeTags !== undefined) {
      AvailableTags.encode(message.availableProgressionModeTags, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Blueprint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlueprint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blueprintId = BlueprintId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.availableGameData = AvailableGameData.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.availableTags = AvailableTags.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.availableThumbnailUrls.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.availableProgressionModeTags = AvailableTags.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Blueprint>): Blueprint {
    return Blueprint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Blueprint>): Blueprint {
    const message = createBaseBlueprint();
    message.blueprintId = (object.blueprintId !== undefined && object.blueprintId !== null)
      ? BlueprintId.fromPartial(object.blueprintId)
      : undefined;
    message.name = object.name ?? "";
    message.availableGameData = (object.availableGameData !== undefined && object.availableGameData !== null)
      ? AvailableGameData.fromPartial(object.availableGameData)
      : undefined;
    message.availableTags = (object.availableTags !== undefined && object.availableTags !== null)
      ? AvailableTags.fromPartial(object.availableTags)
      : undefined;
    message.availableThumbnailUrls = object.availableThumbnailUrls?.map((e) => e) || [];
    message.availableProgressionModeTags =
      (object.availableProgressionModeTags !== undefined && object.availableProgressionModeTags !== null)
        ? AvailableTags.fromPartial(object.availableProgressionModeTags)
        : undefined;
    return message;
  },
};

function createBaseAvailableGameData(): AvailableGameData {
  return { mutators: [], maps: [], modRules: undefined, assetCategories: undefined, spatialAssetInfo: undefined };
}

export const AvailableGameData: MessageFns<AvailableGameData> = {
  encode(message: AvailableGameData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.mutators) {
      AvailableMutator.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.maps) {
      AvailableMapEntry.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.modRules !== undefined) {
      ModRulesDefinition.encode(message.modRules, writer.uint32(26).fork()).join();
    }
    if (message.assetCategories !== undefined) {
      AvailableAssetCategories.encode(message.assetCategories, writer.uint32(34).fork()).join();
    }
    if (message.spatialAssetInfo !== undefined) {
      AssetInfo.encode(message.spatialAssetInfo, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AvailableGameData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvailableGameData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mutators.push(AvailableMutator.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.maps.push(AvailableMapEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.modRules = ModRulesDefinition.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.assetCategories = AvailableAssetCategories.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.spatialAssetInfo = AssetInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AvailableGameData>): AvailableGameData {
    return AvailableGameData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AvailableGameData>): AvailableGameData {
    const message = createBaseAvailableGameData();
    message.mutators = object.mutators?.map((e) => AvailableMutator.fromPartial(e)) || [];
    message.maps = object.maps?.map((e) => AvailableMapEntry.fromPartial(e)) || [];
    message.modRules = (object.modRules !== undefined && object.modRules !== null)
      ? ModRulesDefinition.fromPartial(object.modRules)
      : undefined;
    message.assetCategories = (object.assetCategories !== undefined && object.assetCategories !== null)
      ? AvailableAssetCategories.fromPartial(object.assetCategories)
      : undefined;
    message.spatialAssetInfo = (object.spatialAssetInfo !== undefined && object.spatialAssetInfo !== null)
      ? AssetInfo.fromPartial(object.spatialAssetInfo)
      : undefined;
    return message;
  },
};

function createBaseAssetInfo(): AssetInfo {
  return {};
}

export const AssetInfo: MessageFns<AssetInfo> = {
  encode(_: AssetInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssetInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AssetInfo>): AssetInfo {
    return AssetInfo.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<AssetInfo>): AssetInfo {
    const message = createBaseAssetInfo();
    return message;
  },
};

function createBasePrefab(): Prefab {
  return { prefabInstance: "", prefabPartition: "", prefabType: "", gemInstance: "", gemPartition: "", gemType: "" };
}

export const Prefab: MessageFns<Prefab> = {
  encode(message: Prefab, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prefabInstance !== "") {
      writer.uint32(10).string(message.prefabInstance);
    }
    if (message.prefabPartition !== "") {
      writer.uint32(18).string(message.prefabPartition);
    }
    if (message.prefabType !== "") {
      writer.uint32(26).string(message.prefabType);
    }
    if (message.gemInstance !== "") {
      writer.uint32(34).string(message.gemInstance);
    }
    if (message.gemPartition !== "") {
      writer.uint32(42).string(message.gemPartition);
    }
    if (message.gemType !== "") {
      writer.uint32(50).string(message.gemType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Prefab {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrefab();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.prefabInstance = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.prefabPartition = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.prefabType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.gemInstance = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.gemPartition = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.gemType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Prefab>): Prefab {
    return Prefab.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Prefab>): Prefab {
    const message = createBasePrefab();
    message.prefabInstance = object.prefabInstance ?? "";
    message.prefabPartition = object.prefabPartition ?? "";
    message.prefabType = object.prefabType ?? "";
    message.gemInstance = object.gemInstance ?? "";
    message.gemPartition = object.gemPartition ?? "";
    message.gemType = object.gemType ?? "";
    return message;
  },
};

function createBaseEntityList(): EntityList {
  return { entity: [] };
}

export const EntityList: MessageFns<EntityList> = {
  encode(message: EntityList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entity) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EntityList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntityList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entity.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<EntityList>): EntityList {
    return EntityList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EntityList>): EntityList {
    const message = createBaseEntityList();
    message.entity = object.entity?.map((e) => e) || [];
    return message;
  },
};

function createBaseAvailableAssetCategories(): AvailableAssetCategories {
  return { rootTags: [], tags: [] };
}

export const AvailableAssetCategories: MessageFns<AvailableAssetCategories> = {
  encode(message: AvailableAssetCategories, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.rootTags) {
      AvailableAssetCategoryTag.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.tags) {
      AvailableAssetCategoryTag.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AvailableAssetCategories {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvailableAssetCategories();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rootTags.push(AvailableAssetCategoryTag.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tags.push(AvailableAssetCategoryTag.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AvailableAssetCategories>): AvailableAssetCategories {
    return AvailableAssetCategories.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AvailableAssetCategories>): AvailableAssetCategories {
    const message = createBaseAvailableAssetCategories();
    message.rootTags = object.rootTags?.map((e) => AvailableAssetCategoryTag.fromPartial(e)) || [];
    message.tags = object.tags?.map((e) => AvailableAssetCategoryTag.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAvailableAssetCategoryTag(): AvailableAssetCategoryTag {
  return { tagId: "", name: "", childrenTags: [], metadata: undefined };
}

export const AvailableAssetCategoryTag: MessageFns<AvailableAssetCategoryTag> = {
  encode(message: AvailableAssetCategoryTag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tagId !== "") {
      writer.uint32(10).string(message.tagId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    for (const v of message.childrenTags) {
      writer.uint32(26).string(v!);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AvailableAssetCategoryTag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvailableAssetCategoryTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tagId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.childrenTags.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AvailableAssetCategoryTag>): AvailableAssetCategoryTag {
    return AvailableAssetCategoryTag.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AvailableAssetCategoryTag>): AvailableAssetCategoryTag {
    const message = createBaseAvailableAssetCategoryTag();
    message.tagId = object.tagId ?? "";
    message.name = object.name ?? "";
    message.childrenTags = object.childrenTags?.map((e) => e) || [];
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseModRulesDefinition(): ModRulesDefinition {
  return { rulesVersion: 0, modBuilder: new Uint8Array(0) };
}

export const ModRulesDefinition: MessageFns<ModRulesDefinition> = {
  encode(message: ModRulesDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rulesVersion !== 0) {
      writer.uint32(8).int32(message.rulesVersion);
    }
    if (message.modBuilder.length !== 0) {
      writer.uint32(18).bytes(message.modBuilder);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModRulesDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModRulesDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.rulesVersion = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modBuilder = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ModRulesDefinition>): ModRulesDefinition {
    return ModRulesDefinition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ModRulesDefinition>): ModRulesDefinition {
    const message = createBaseModRulesDefinition();
    message.rulesVersion = object.rulesVersion ?? 0;
    message.modBuilder = object.modBuilder ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAvailableTag(): AvailableTag {
  return { id: "", metadata: undefined, category: undefined };
}

export const AvailableTag: MessageFns<AvailableTag> = {
  encode(message: AvailableTag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(18).fork()).join();
    }
    if (message.category !== undefined) {
      writer.uint32(26).string(message.category);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AvailableTag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvailableTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.category = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AvailableTag>): AvailableTag {
    return AvailableTag.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AvailableTag>): AvailableTag {
    const message = createBaseAvailableTag();
    message.id = object.id ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.category = object.category ?? undefined;
    return message;
  },
};

function createBaseAvailableMapEntry(): AvailableMapEntry {
  return {
    levelName: "",
    levelLocation: "",
    gameSize: undefined,
    rounds: undefined,
    allowedSpectators: undefined,
    metadata: undefined,
    allowedTeamsRange: undefined,
  };
}

export const AvailableMapEntry: MessageFns<AvailableMapEntry> = {
  encode(message: AvailableMapEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.levelName !== "") {
      writer.uint32(10).string(message.levelName);
    }
    if (message.levelLocation !== "") {
      writer.uint32(18).string(message.levelLocation);
    }
    if (message.gameSize !== undefined) {
      AvailableIntValue.encode(message.gameSize, writer.uint32(26).fork()).join();
    }
    if (message.rounds !== undefined) {
      AvailableIntValue.encode(message.rounds, writer.uint32(34).fork()).join();
    }
    if (message.allowedSpectators !== undefined) {
      AvailableIntValue.encode(message.allowedSpectators, writer.uint32(42).fork()).join();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(50).fork()).join();
    }
    if (message.allowedTeamsRange !== undefined) {
      AvailableIntValue.encode(message.allowedTeamsRange, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AvailableMapEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvailableMapEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.levelName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.levelLocation = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.gameSize = AvailableIntValue.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.rounds = AvailableIntValue.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.allowedSpectators = AvailableIntValue.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.allowedTeamsRange = AvailableIntValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AvailableMapEntry>): AvailableMapEntry {
    return AvailableMapEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AvailableMapEntry>): AvailableMapEntry {
    const message = createBaseAvailableMapEntry();
    message.levelName = object.levelName ?? "";
    message.levelLocation = object.levelLocation ?? "";
    message.gameSize = (object.gameSize !== undefined && object.gameSize !== null)
      ? AvailableIntValue.fromPartial(object.gameSize)
      : undefined;
    message.rounds = (object.rounds !== undefined && object.rounds !== null)
      ? AvailableIntValue.fromPartial(object.rounds)
      : undefined;
    message.allowedSpectators = (object.allowedSpectators !== undefined && object.allowedSpectators !== null)
      ? AvailableIntValue.fromPartial(object.allowedSpectators)
      : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.allowedTeamsRange = (object.allowedTeamsRange !== undefined && object.allowedTeamsRange !== null)
      ? AvailableIntValue.fromPartial(object.allowedTeamsRange)
      : undefined;
    return message;
  },
};

function createBaseAvailableIntValue(): AvailableIntValue {
  return { defaultValue: 0, availableValues: undefined };
}

export const AvailableIntValue: MessageFns<AvailableIntValue> = {
  encode(message: AvailableIntValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.defaultValue !== 0) {
      writer.uint32(8).int32(message.defaultValue);
    }
    if (message.availableValues !== undefined) {
      AvailableIntValues.encode(message.availableValues, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AvailableIntValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvailableIntValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.defaultValue = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.availableValues = AvailableIntValues.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AvailableIntValue>): AvailableIntValue {
    return AvailableIntValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AvailableIntValue>): AvailableIntValue {
    const message = createBaseAvailableIntValue();
    message.defaultValue = object.defaultValue ?? 0;
    message.availableValues = (object.availableValues !== undefined && object.availableValues !== null)
      ? AvailableIntValues.fromPartial(object.availableValues)
      : undefined;
    return message;
  },
};

function createBaseAvailableIntValues(): AvailableIntValues {
  return { range: undefined, sparseValues: undefined };
}

export const AvailableIntValues: MessageFns<AvailableIntValues> = {
  encode(message: AvailableIntValues, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.range !== undefined) {
      IntRange.encode(message.range, writer.uint32(10).fork()).join();
    }
    if (message.sparseValues !== undefined) {
      SparseIntValues.encode(message.sparseValues, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AvailableIntValues {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvailableIntValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.range = IntRange.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sparseValues = SparseIntValues.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AvailableIntValues>): AvailableIntValues {
    return AvailableIntValues.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AvailableIntValues>): AvailableIntValues {
    const message = createBaseAvailableIntValues();
    message.range = (object.range !== undefined && object.range !== null)
      ? IntRange.fromPartial(object.range)
      : undefined;
    message.sparseValues = (object.sparseValues !== undefined && object.sparseValues !== null)
      ? SparseIntValues.fromPartial(object.sparseValues)
      : undefined;
    return message;
  },
};

function createBaseSparseIntValues(): SparseIntValues {
  return { values: [] };
}

export const SparseIntValues: MessageFns<SparseIntValues> = {
  encode(message: SparseIntValues, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.values) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SparseIntValues {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSparseIntValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.values.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.values.push(reader.int32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SparseIntValues>): SparseIntValues {
    return SparseIntValues.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SparseIntValues>): SparseIntValues {
    const message = createBaseSparseIntValues();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseIntRange(): IntRange {
  return { minValue: 0, maxValue: 0 };
}

export const IntRange: MessageFns<IntRange> = {
  encode(message: IntRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minValue !== 0) {
      writer.uint32(8).int32(message.minValue);
    }
    if (message.maxValue !== 0) {
      writer.uint32(16).int32(message.maxValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IntRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.minValue = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maxValue = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<IntRange>): IntRange {
    return IntRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IntRange>): IntRange {
    const message = createBaseIntRange();
    message.minValue = object.minValue ?? 0;
    message.maxValue = object.maxValue ?? 0;
    return message;
  },
};

function createBaseAvailableTags(): AvailableTags {
  return { tags: [] };
}

export const AvailableTags: MessageFns<AvailableTags> = {
  encode(message: AvailableTags, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tags) {
      AvailableTag.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AvailableTags {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvailableTags();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tags.push(AvailableTag.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AvailableTags>): AvailableTags {
    return AvailableTags.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AvailableTags>): AvailableTags {
    const message = createBaseAvailableTags();
    message.tags = object.tags?.map((e) => AvailableTag.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAvailableMutator(): AvailableMutator {
  return { name: "", category: "", kind: undefined, metadata: undefined, id: "" };
}

export const AvailableMutator: MessageFns<AvailableMutator> = {
  encode(message: AvailableMutator, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.category !== "") {
      writer.uint32(18).string(message.category);
    }
    if (message.kind !== undefined) {
      AvailableMutatorKind.encode(message.kind, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.id !== "") {
      writer.uint32(42).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AvailableMutator {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvailableMutator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.kind = AvailableMutatorKind.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AvailableMutator>): AvailableMutator {
    return AvailableMutator.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AvailableMutator>): AvailableMutator {
    const message = createBaseAvailableMutator();
    message.name = object.name ?? "";
    message.category = object.category ?? "";
    message.kind = (object.kind !== undefined && object.kind !== null)
      ? AvailableMutatorKind.fromPartial(object.kind)
      : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseAvailableMutatorKind(): AvailableMutatorKind {
  return {
    mutatorBoolean: undefined,
    mutatorString: undefined,
    mutatorFloatValues: undefined,
    mutatorIntValues: undefined,
    mutatorSparseBoolean: undefined,
    mutatorSparseIntValues: undefined,
    mutatorSparseFloatValues: undefined,
  };
}

export const AvailableMutatorKind: MessageFns<AvailableMutatorKind> = {
  encode(message: AvailableMutatorKind, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mutatorBoolean !== undefined) {
      MutatorBoolean.encode(message.mutatorBoolean, writer.uint32(10).fork()).join();
    }
    if (message.mutatorString !== undefined) {
      MutatorString.encode(message.mutatorString, writer.uint32(34).fork()).join();
    }
    if (message.mutatorFloatValues !== undefined) {
      AvailableMutatorFloatValues.encode(message.mutatorFloatValues, writer.uint32(42).fork()).join();
    }
    if (message.mutatorIntValues !== undefined) {
      AvailableMutatorIntValues.encode(message.mutatorIntValues, writer.uint32(50).fork()).join();
    }
    if (message.mutatorSparseBoolean !== undefined) {
      MutatorSparseBoolean.encode(message.mutatorSparseBoolean, writer.uint32(58).fork()).join();
    }
    if (message.mutatorSparseIntValues !== undefined) {
      AvailableMutatorSparseIntValues.encode(message.mutatorSparseIntValues, writer.uint32(66).fork()).join();
    }
    if (message.mutatorSparseFloatValues !== undefined) {
      AvailableMutatorSparseFloatValues.encode(message.mutatorSparseFloatValues, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AvailableMutatorKind {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvailableMutatorKind();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mutatorBoolean = MutatorBoolean.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.mutatorString = MutatorString.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.mutatorFloatValues = AvailableMutatorFloatValues.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.mutatorIntValues = AvailableMutatorIntValues.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.mutatorSparseBoolean = MutatorSparseBoolean.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.mutatorSparseIntValues = AvailableMutatorSparseIntValues.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.mutatorSparseFloatValues = AvailableMutatorSparseFloatValues.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AvailableMutatorKind>): AvailableMutatorKind {
    return AvailableMutatorKind.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AvailableMutatorKind>): AvailableMutatorKind {
    const message = createBaseAvailableMutatorKind();
    message.mutatorBoolean = (object.mutatorBoolean !== undefined && object.mutatorBoolean !== null)
      ? MutatorBoolean.fromPartial(object.mutatorBoolean)
      : undefined;
    message.mutatorString = (object.mutatorString !== undefined && object.mutatorString !== null)
      ? MutatorString.fromPartial(object.mutatorString)
      : undefined;
    message.mutatorFloatValues = (object.mutatorFloatValues !== undefined && object.mutatorFloatValues !== null)
      ? AvailableMutatorFloatValues.fromPartial(object.mutatorFloatValues)
      : undefined;
    message.mutatorIntValues = (object.mutatorIntValues !== undefined && object.mutatorIntValues !== null)
      ? AvailableMutatorIntValues.fromPartial(object.mutatorIntValues)
      : undefined;
    message.mutatorSparseBoolean = (object.mutatorSparseBoolean !== undefined && object.mutatorSparseBoolean !== null)
      ? MutatorSparseBoolean.fromPartial(object.mutatorSparseBoolean)
      : undefined;
    message.mutatorSparseIntValues =
      (object.mutatorSparseIntValues !== undefined && object.mutatorSparseIntValues !== null)
        ? AvailableMutatorSparseIntValues.fromPartial(object.mutatorSparseIntValues)
        : undefined;
    message.mutatorSparseFloatValues =
      (object.mutatorSparseFloatValues !== undefined && object.mutatorSparseFloatValues !== null)
        ? AvailableMutatorSparseFloatValues.fromPartial(object.mutatorSparseFloatValues)
        : undefined;
    return message;
  },
};

function createBaseAvailableMutatorSparseIntValues(): AvailableMutatorSparseIntValues {
  return { mutator: undefined, availableValues: undefined };
}

export const AvailableMutatorSparseIntValues: MessageFns<AvailableMutatorSparseIntValues> = {
  encode(message: AvailableMutatorSparseIntValues, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mutator !== undefined) {
      MutatorSparseInt.encode(message.mutator, writer.uint32(10).fork()).join();
    }
    if (message.availableValues !== undefined) {
      AvailableIntValues.encode(message.availableValues, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AvailableMutatorSparseIntValues {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvailableMutatorSparseIntValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mutator = MutatorSparseInt.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.availableValues = AvailableIntValues.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AvailableMutatorSparseIntValues>): AvailableMutatorSparseIntValues {
    return AvailableMutatorSparseIntValues.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AvailableMutatorSparseIntValues>): AvailableMutatorSparseIntValues {
    const message = createBaseAvailableMutatorSparseIntValues();
    message.mutator = (object.mutator !== undefined && object.mutator !== null)
      ? MutatorSparseInt.fromPartial(object.mutator)
      : undefined;
    message.availableValues = (object.availableValues !== undefined && object.availableValues !== null)
      ? AvailableIntValues.fromPartial(object.availableValues)
      : undefined;
    return message;
  },
};

function createBaseAvailableMutatorSparseFloatValues(): AvailableMutatorSparseFloatValues {
  return { mutator: undefined, availableValues: undefined };
}

export const AvailableMutatorSparseFloatValues: MessageFns<AvailableMutatorSparseFloatValues> = {
  encode(message: AvailableMutatorSparseFloatValues, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mutator !== undefined) {
      MutatorSparseFloat.encode(message.mutator, writer.uint32(10).fork()).join();
    }
    if (message.availableValues !== undefined) {
      AvailableFloatValues.encode(message.availableValues, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AvailableMutatorSparseFloatValues {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvailableMutatorSparseFloatValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mutator = MutatorSparseFloat.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.availableValues = AvailableFloatValues.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AvailableMutatorSparseFloatValues>): AvailableMutatorSparseFloatValues {
    return AvailableMutatorSparseFloatValues.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AvailableMutatorSparseFloatValues>): AvailableMutatorSparseFloatValues {
    const message = createBaseAvailableMutatorSparseFloatValues();
    message.mutator = (object.mutator !== undefined && object.mutator !== null)
      ? MutatorSparseFloat.fromPartial(object.mutator)
      : undefined;
    message.availableValues = (object.availableValues !== undefined && object.availableValues !== null)
      ? AvailableFloatValues.fromPartial(object.availableValues)
      : undefined;
    return message;
  },
};

function createBaseCreatePlayElementRequest(): CreatePlayElementRequest {
  return {
    name: "",
    description: undefined,
    designMetadata: undefined,
    mapRotation: undefined,
    mutators: [],
    assetCategories: [],
    originalModRules: new Uint8Array(0),
    playElementSettings: undefined,
    publishState: 0,
    modLevelDataId: undefined,
    thumbnailUrl: undefined,
    attachments: [],
  };
}

export const CreatePlayElementRequest: MessageFns<CreatePlayElementRequest> = {
  encode(message: CreatePlayElementRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== undefined) {
      writer.uint32(18).string(message.description);
    }
    if (message.designMetadata !== undefined) {
      DesignMetadata.encode(message.designMetadata, writer.uint32(26).fork()).join();
    }
    if (message.mapRotation !== undefined) {
      MapRotation.encode(message.mapRotation, writer.uint32(34).fork()).join();
    }
    for (const v of message.mutators) {
      Mutator.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.assetCategories) {
      AssetCategory.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.originalModRules.length !== 0) {
      writer.uint32(58).bytes(message.originalModRules);
    }
    if (message.playElementSettings !== undefined) {
      PlayElementSettings.encode(message.playElementSettings, writer.uint32(66).fork()).join();
    }
    if (message.publishState !== 0) {
      writer.uint32(72).int32(message.publishState);
    }
    if (message.modLevelDataId !== undefined) {
      writer.uint32(82).string(message.modLevelDataId);
    }
    if (message.thumbnailUrl !== undefined) {
      writer.uint32(90).string(message.thumbnailUrl);
    }
    for (const v of message.attachments) {
      Attachment.encode(v!, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePlayElementRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePlayElementRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.designMetadata = DesignMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.mapRotation = MapRotation.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.mutators.push(Mutator.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.assetCategories.push(AssetCategory.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.originalModRules = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.playElementSettings = PlayElementSettings.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.publishState = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.modLevelDataId = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.thumbnailUrl = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.attachments.push(Attachment.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<CreatePlayElementRequest>): CreatePlayElementRequest {
    return CreatePlayElementRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreatePlayElementRequest>): CreatePlayElementRequest {
    const message = createBaseCreatePlayElementRequest();
    message.name = object.name ?? "";
    message.description = object.description ?? undefined;
    message.designMetadata = (object.designMetadata !== undefined && object.designMetadata !== null)
      ? DesignMetadata.fromPartial(object.designMetadata)
      : undefined;
    message.mapRotation = (object.mapRotation !== undefined && object.mapRotation !== null)
      ? MapRotation.fromPartial(object.mapRotation)
      : undefined;
    message.mutators = object.mutators?.map((e) => Mutator.fromPartial(e)) || [];
    message.assetCategories = object.assetCategories?.map((e) => AssetCategory.fromPartial(e)) || [];
    message.originalModRules = object.originalModRules ?? new Uint8Array(0);
    message.playElementSettings = (object.playElementSettings !== undefined && object.playElementSettings !== null)
      ? PlayElementSettings.fromPartial(object.playElementSettings)
      : undefined;
    message.publishState = object.publishState ?? 0;
    message.modLevelDataId = object.modLevelDataId ?? undefined;
    message.thumbnailUrl = object.thumbnailUrl ?? undefined;
    message.attachments = object.attachments?.map((e) => Attachment.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAvailableMutatorFloatValues(): AvailableMutatorFloatValues {
  return { mutator: undefined, availableValues: undefined };
}

export const AvailableMutatorFloatValues: MessageFns<AvailableMutatorFloatValues> = {
  encode(message: AvailableMutatorFloatValues, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mutator !== undefined) {
      MutatorFloat.encode(message.mutator, writer.uint32(10).fork()).join();
    }
    if (message.availableValues !== undefined) {
      AvailableFloatValues.encode(message.availableValues, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AvailableMutatorFloatValues {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvailableMutatorFloatValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mutator = MutatorFloat.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.availableValues = AvailableFloatValues.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AvailableMutatorFloatValues>): AvailableMutatorFloatValues {
    return AvailableMutatorFloatValues.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AvailableMutatorFloatValues>): AvailableMutatorFloatValues {
    const message = createBaseAvailableMutatorFloatValues();
    message.mutator = (object.mutator !== undefined && object.mutator !== null)
      ? MutatorFloat.fromPartial(object.mutator)
      : undefined;
    message.availableValues = (object.availableValues !== undefined && object.availableValues !== null)
      ? AvailableFloatValues.fromPartial(object.availableValues)
      : undefined;
    return message;
  },
};

function createBaseAvailableFloatValues(): AvailableFloatValues {
  return { range: undefined, sparseValues: undefined };
}

export const AvailableFloatValues: MessageFns<AvailableFloatValues> = {
  encode(message: AvailableFloatValues, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.range !== undefined) {
      FloatRange.encode(message.range, writer.uint32(10).fork()).join();
    }
    if (message.sparseValues !== undefined) {
      SparseFloatValues.encode(message.sparseValues, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AvailableFloatValues {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvailableFloatValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.range = FloatRange.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sparseValues = SparseFloatValues.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AvailableFloatValues>): AvailableFloatValues {
    return AvailableFloatValues.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AvailableFloatValues>): AvailableFloatValues {
    const message = createBaseAvailableFloatValues();
    message.range = (object.range !== undefined && object.range !== null)
      ? FloatRange.fromPartial(object.range)
      : undefined;
    message.sparseValues = (object.sparseValues !== undefined && object.sparseValues !== null)
      ? SparseFloatValues.fromPartial(object.sparseValues)
      : undefined;
    return message;
  },
};

function createBaseSparseFloatValues(): SparseFloatValues {
  return { values: [] };
}

export const SparseFloatValues: MessageFns<SparseFloatValues> = {
  encode(message: SparseFloatValues, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.values) {
      writer.float(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SparseFloatValues {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSparseFloatValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 13) {
            message.values.push(reader.float());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.values.push(reader.float());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SparseFloatValues>): SparseFloatValues {
    return SparseFloatValues.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SparseFloatValues>): SparseFloatValues {
    const message = createBaseSparseFloatValues();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseFloatRange(): FloatRange {
  return { minValue: 0, maxValue: 0 };
}

export const FloatRange: MessageFns<FloatRange> = {
  encode(message: FloatRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minValue !== 0) {
      writer.uint32(13).float(message.minValue);
    }
    if (message.maxValue !== 0) {
      writer.uint32(21).float(message.maxValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FloatRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFloatRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.minValue = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.maxValue = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<FloatRange>): FloatRange {
    return FloatRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FloatRange>): FloatRange {
    const message = createBaseFloatRange();
    message.minValue = object.minValue ?? 0;
    message.maxValue = object.maxValue ?? 0;
    return message;
  },
};

function createBaseAvailableMutatorIntValues(): AvailableMutatorIntValues {
  return { mutator: undefined, availableValues: undefined };
}

export const AvailableMutatorIntValues: MessageFns<AvailableMutatorIntValues> = {
  encode(message: AvailableMutatorIntValues, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mutator !== undefined) {
      MutatorInt.encode(message.mutator, writer.uint32(10).fork()).join();
    }
    if (message.availableValues !== undefined) {
      AvailableIntValues.encode(message.availableValues, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AvailableMutatorIntValues {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvailableMutatorIntValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mutator = MutatorInt.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.availableValues = AvailableIntValues.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AvailableMutatorIntValues>): AvailableMutatorIntValues {
    return AvailableMutatorIntValues.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AvailableMutatorIntValues>): AvailableMutatorIntValues {
    const message = createBaseAvailableMutatorIntValues();
    message.mutator = (object.mutator !== undefined && object.mutator !== null)
      ? MutatorInt.fromPartial(object.mutator)
      : undefined;
    message.availableValues = (object.availableValues !== undefined && object.availableValues !== null)
      ? AvailableIntValues.fromPartial(object.availableValues)
      : undefined;
    return message;
  },
};

function createBaseUpdatePlayElementRequest(): UpdatePlayElementRequest {
  return {
    id: "",
    name: "",
    description: undefined,
    designMetadata: undefined,
    mapRotation: undefined,
    mutators: [],
    assetCategories: [],
    originalModRules: new Uint8Array(0),
    playElementSettings: undefined,
    publishState: 0,
    modLevelDataId: undefined,
    thumbnailUrl: undefined,
    attachments: [],
  };
}

export const UpdatePlayElementRequest: MessageFns<UpdatePlayElementRequest> = {
  encode(message: UpdatePlayElementRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== undefined) {
      writer.uint32(26).string(message.description);
    }
    if (message.designMetadata !== undefined) {
      DesignMetadata.encode(message.designMetadata, writer.uint32(34).fork()).join();
    }
    if (message.mapRotation !== undefined) {
      MapRotation.encode(message.mapRotation, writer.uint32(42).fork()).join();
    }
    for (const v of message.mutators) {
      Mutator.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.assetCategories) {
      AssetCategory.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.originalModRules.length !== 0) {
      writer.uint32(66).bytes(message.originalModRules);
    }
    if (message.playElementSettings !== undefined) {
      PlayElementSettings.encode(message.playElementSettings, writer.uint32(74).fork()).join();
    }
    if (message.publishState !== 0) {
      writer.uint32(80).int32(message.publishState);
    }
    if (message.modLevelDataId !== undefined) {
      writer.uint32(90).string(message.modLevelDataId);
    }
    if (message.thumbnailUrl !== undefined) {
      writer.uint32(98).string(message.thumbnailUrl);
    }
    for (const v of message.attachments) {
      Attachment.encode(v!, writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatePlayElementRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePlayElementRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.designMetadata = DesignMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.mapRotation = MapRotation.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.mutators.push(Mutator.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.assetCategories.push(AssetCategory.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.originalModRules = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.playElementSettings = PlayElementSettings.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.publishState = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.modLevelDataId = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.thumbnailUrl = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.attachments.push(Attachment.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<UpdatePlayElementRequest>): UpdatePlayElementRequest {
    return UpdatePlayElementRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdatePlayElementRequest>): UpdatePlayElementRequest {
    const message = createBaseUpdatePlayElementRequest();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? undefined;
    message.designMetadata = (object.designMetadata !== undefined && object.designMetadata !== null)
      ? DesignMetadata.fromPartial(object.designMetadata)
      : undefined;
    message.mapRotation = (object.mapRotation !== undefined && object.mapRotation !== null)
      ? MapRotation.fromPartial(object.mapRotation)
      : undefined;
    message.mutators = object.mutators?.map((e) => Mutator.fromPartial(e)) || [];
    message.assetCategories = object.assetCategories?.map((e) => AssetCategory.fromPartial(e)) || [];
    message.originalModRules = object.originalModRules ?? new Uint8Array(0);
    message.playElementSettings = (object.playElementSettings !== undefined && object.playElementSettings !== null)
      ? PlayElementSettings.fromPartial(object.playElementSettings)
      : undefined;
    message.publishState = object.publishState ?? 0;
    message.modLevelDataId = object.modLevelDataId ?? undefined;
    message.thumbnailUrl = object.thumbnailUrl ?? undefined;
    message.attachments = object.attachments?.map((e) => Attachment.fromPartial(e)) || [];
    return message;
  },
};

function createBasePlayElementResponse(): PlayElementResponse {
  return { playElement: undefined, playElementDesign: undefined, progressionMode: undefined };
}

export const PlayElementResponse: MessageFns<PlayElementResponse> = {
  encode(message: PlayElementResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playElement !== undefined) {
      PlayElement.encode(message.playElement, writer.uint32(10).fork()).join();
    }
    if (message.playElementDesign !== undefined) {
      PlayElementDesign.encode(message.playElementDesign, writer.uint32(18).fork()).join();
    }
    if (message.progressionMode !== undefined) {
      writer.uint32(26).string(message.progressionMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayElementResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayElementResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playElement = PlayElement.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.playElementDesign = PlayElementDesign.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.progressionMode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PlayElementResponse>): PlayElementResponse {
    return PlayElementResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlayElementResponse>): PlayElementResponse {
    const message = createBasePlayElementResponse();
    message.playElement = (object.playElement !== undefined && object.playElement !== null)
      ? PlayElement.fromPartial(object.playElement)
      : undefined;
    message.playElementDesign = (object.playElementDesign !== undefined && object.playElementDesign !== null)
      ? PlayElementDesign.fromPartial(object.playElementDesign)
      : undefined;
    message.progressionMode = object.progressionMode ?? undefined;
    return message;
  },
};

function createBasePlayElement(): PlayElement {
  return {
    id: "",
    designId: "",
    creator: undefined,
    name: "",
    description: undefined,
    created: undefined,
    updated: undefined,
    playElementSettings: undefined,
    publishStateType: 0,
    likes: undefined,
    publishAt: undefined,
    thumbnailUrl: undefined,
    moderationState: 0,
    shortCode: undefined,
  };
}

export const PlayElement: MessageFns<PlayElement> = {
  encode(message: PlayElement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.designId !== "") {
      writer.uint32(18).string(message.designId);
    }
    if (message.creator !== undefined) {
      Creator.encode(message.creator, writer.uint32(26).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.description !== undefined) {
      writer.uint32(42).string(message.description);
    }
    if (message.created !== undefined) {
      writer.uint32(48).uint32(message.created);
    }
    if (message.updated !== undefined) {
      writer.uint32(56).uint32(message.updated);
    }
    if (message.playElementSettings !== undefined) {
      PlayElementSettings.encode(message.playElementSettings, writer.uint32(66).fork()).join();
    }
    if (message.publishStateType !== 0) {
      writer.uint32(72).int32(message.publishStateType);
    }
    if (message.likes !== undefined) {
      writer.uint32(80).int32(message.likes);
    }
    if (message.publishAt !== undefined) {
      writer.uint32(88).uint32(message.publishAt);
    }
    if (message.thumbnailUrl !== undefined) {
      writer.uint32(98).string(message.thumbnailUrl);
    }
    if (message.moderationState !== 0) {
      writer.uint32(104).int32(message.moderationState);
    }
    if (message.shortCode !== undefined) {
      writer.uint32(114).string(message.shortCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayElement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayElement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.designId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.creator = Creator.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.created = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.updated = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.playElementSettings = PlayElementSettings.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.publishStateType = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.likes = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.publishAt = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.thumbnailUrl = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.moderationState = reader.int32() as any;
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.shortCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PlayElement>): PlayElement {
    return PlayElement.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlayElement>): PlayElement {
    const message = createBasePlayElement();
    message.id = object.id ?? "";
    message.designId = object.designId ?? "";
    message.creator = (object.creator !== undefined && object.creator !== null)
      ? Creator.fromPartial(object.creator)
      : undefined;
    message.name = object.name ?? "";
    message.description = object.description ?? undefined;
    message.created = object.created ?? undefined;
    message.updated = object.updated ?? undefined;
    message.playElementSettings = (object.playElementSettings !== undefined && object.playElementSettings !== null)
      ? PlayElementSettings.fromPartial(object.playElementSettings)
      : undefined;
    message.publishStateType = object.publishStateType ?? 0;
    message.likes = object.likes ?? undefined;
    message.publishAt = object.publishAt ?? undefined;
    message.thumbnailUrl = object.thumbnailUrl ?? undefined;
    message.moderationState = object.moderationState ?? 0;
    message.shortCode = object.shortCode ?? undefined;
    return message;
  },
};

function createBasePlayElementDesign(): PlayElementDesign {
  return {
    designId: "",
    designName: "",
    updated: undefined,
    designMetadata: undefined,
    mapRotation: undefined,
    mutators: [],
    assetCategories: [],
    licenseRequirements: [],
    modRules: undefined,
    tags: [],
    blazeSettings: undefined,
    modLevelDataId: undefined,
    attachments: [],
    groupLicenses: [],
    attachmentCompileStatus: 0,
    serverHostLicenseRequirements: [],
  };
}

export const PlayElementDesign: MessageFns<PlayElementDesign> = {
  encode(message: PlayElementDesign, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.designId !== "") {
      writer.uint32(10).string(message.designId);
    }
    if (message.designName !== "") {
      writer.uint32(18).string(message.designName);
    }
    if (message.updated !== undefined) {
      writer.uint32(32).uint32(message.updated);
    }
    if (message.designMetadata !== undefined) {
      DesignMetadata.encode(message.designMetadata, writer.uint32(42).fork()).join();
    }
    if (message.mapRotation !== undefined) {
      MapRotation.encode(message.mapRotation, writer.uint32(50).fork()).join();
    }
    for (const v of message.mutators) {
      Mutator.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.assetCategories) {
      AssetCategory.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.licenseRequirements) {
      writer.uint32(74).string(v!);
    }
    if (message.modRules !== undefined) {
      ModRules.encode(message.modRules, writer.uint32(82).fork()).join();
    }
    for (const v of message.tags) {
      Tag.encode(v!, writer.uint32(90).fork()).join();
    }
    if (message.blazeSettings !== undefined) {
      BlazePlayElementDesignSettings.encode(message.blazeSettings, writer.uint32(98).fork()).join();
    }
    if (message.modLevelDataId !== undefined) {
      writer.uint32(106).string(message.modLevelDataId);
    }
    for (const v of message.attachments) {
      Attachment.encode(v!, writer.uint32(114).fork()).join();
    }
    for (const v of message.groupLicenses) {
      writer.uint32(122).string(v!);
    }
    if (message.attachmentCompileStatus !== 0) {
      writer.uint32(128).int32(message.attachmentCompileStatus);
    }
    for (const v of message.serverHostLicenseRequirements) {
      writer.uint32(138).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayElementDesign {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayElementDesign();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.designId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.designName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.updated = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.designMetadata = DesignMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.mapRotation = MapRotation.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.mutators.push(Mutator.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.assetCategories.push(AssetCategory.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.licenseRequirements.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.modRules = ModRules.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.tags.push(Tag.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.blazeSettings = BlazePlayElementDesignSettings.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.modLevelDataId = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.attachments.push(Attachment.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.groupLicenses.push(reader.string());
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.attachmentCompileStatus = reader.int32() as any;
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.serverHostLicenseRequirements.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PlayElementDesign>): PlayElementDesign {
    return PlayElementDesign.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlayElementDesign>): PlayElementDesign {
    const message = createBasePlayElementDesign();
    message.designId = object.designId ?? "";
    message.designName = object.designName ?? "";
    message.updated = object.updated ?? undefined;
    message.designMetadata = (object.designMetadata !== undefined && object.designMetadata !== null)
      ? DesignMetadata.fromPartial(object.designMetadata)
      : undefined;
    message.mapRotation = (object.mapRotation !== undefined && object.mapRotation !== null)
      ? MapRotation.fromPartial(object.mapRotation)
      : undefined;
    message.mutators = object.mutators?.map((e) => Mutator.fromPartial(e)) || [];
    message.assetCategories = object.assetCategories?.map((e) => AssetCategory.fromPartial(e)) || [];
    message.licenseRequirements = object.licenseRequirements?.map((e) => e) || [];
    message.modRules = (object.modRules !== undefined && object.modRules !== null)
      ? ModRules.fromPartial(object.modRules)
      : undefined;
    message.tags = object.tags?.map((e) => Tag.fromPartial(e)) || [];
    message.blazeSettings = (object.blazeSettings !== undefined && object.blazeSettings !== null)
      ? BlazePlayElementDesignSettings.fromPartial(object.blazeSettings)
      : undefined;
    message.modLevelDataId = object.modLevelDataId ?? undefined;
    message.attachments = object.attachments?.map((e) => Attachment.fromPartial(e)) || [];
    message.groupLicenses = object.groupLicenses?.map((e) => e) || [];
    message.attachmentCompileStatus = object.attachmentCompileStatus ?? 0;
    message.serverHostLicenseRequirements = object.serverHostLicenseRequirements?.map((e) => e) || [];
    return message;
  },
};

function createBaseCreator(): Creator {
  return {
    internalCreator: undefined,
    playerCreator: undefined,
    externalCreator: undefined,
    trustedCreator: undefined,
  };
}

export const Creator: MessageFns<Creator> = {
  encode(message: Creator, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.internalCreator !== undefined) {
      InternalCreator.encode(message.internalCreator, writer.uint32(10).fork()).join();
    }
    if (message.playerCreator !== undefined) {
      PlayerCreator.encode(message.playerCreator, writer.uint32(18).fork()).join();
    }
    if (message.externalCreator !== undefined) {
      ExternalCreator.encode(message.externalCreator, writer.uint32(26).fork()).join();
    }
    if (message.trustedCreator !== undefined) {
      PlayerCreator.encode(message.trustedCreator, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Creator {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.internalCreator = InternalCreator.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.playerCreator = PlayerCreator.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.externalCreator = ExternalCreator.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.trustedCreator = PlayerCreator.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Creator>): Creator {
    return Creator.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Creator>): Creator {
    const message = createBaseCreator();
    message.internalCreator = (object.internalCreator !== undefined && object.internalCreator !== null)
      ? InternalCreator.fromPartial(object.internalCreator)
      : undefined;
    message.playerCreator = (object.playerCreator !== undefined && object.playerCreator !== null)
      ? PlayerCreator.fromPartial(object.playerCreator)
      : undefined;
    message.externalCreator = (object.externalCreator !== undefined && object.externalCreator !== null)
      ? ExternalCreator.fromPartial(object.externalCreator)
      : undefined;
    message.trustedCreator = (object.trustedCreator !== undefined && object.trustedCreator !== null)
      ? PlayerCreator.fromPartial(object.trustedCreator)
      : undefined;
    return message;
  },
};

function createBaseInternalCreator(): InternalCreator {
  return {};
}

export const InternalCreator: MessageFns<InternalCreator> = {
  encode(_: InternalCreator, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InternalCreator {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInternalCreator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<InternalCreator>): InternalCreator {
    return InternalCreator.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<InternalCreator>): InternalCreator {
    const message = createBaseInternalCreator();
    return message;
  },
};

function createBasePlayerCreator(): PlayerCreator {
  return { player: undefined };
}

export const PlayerCreator: MessageFns<PlayerCreator> = {
  encode(message: PlayerCreator, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.player !== undefined) {
      Player.encode(message.player, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayerCreator {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayerCreator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.player = Player.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PlayerCreator>): PlayerCreator {
    return PlayerCreator.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlayerCreator>): PlayerCreator {
    const message = createBasePlayerCreator();
    message.player = (object.player !== undefined && object.player !== null)
      ? Player.fromPartial(object.player)
      : undefined;
    return message;
  },
};

function createBaseExternalCreator(): ExternalCreator {
  return {};
}

export const ExternalCreator: MessageFns<ExternalCreator> = {
  encode(_: ExternalCreator, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExternalCreator {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExternalCreator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ExternalCreator>): ExternalCreator {
    return ExternalCreator.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ExternalCreator>): ExternalCreator {
    const message = createBaseExternalCreator();
    return message;
  },
};

function createBasePlayer(): Player {
  return { nucleusId: 0, personaId: 0, platform: 0 };
}

export const Player: MessageFns<Player> = {
  encode(message: Player, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nucleusId !== 0) {
      writer.uint32(8).int64(message.nucleusId);
    }
    if (message.personaId !== 0) {
      writer.uint32(16).int64(message.personaId);
    }
    if (message.platform !== 0) {
      writer.uint32(24).int32(message.platform);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Player {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.nucleusId = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.personaId = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.platform = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Player>): Player {
    return Player.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Player>): Player {
    const message = createBasePlayer();
    message.nucleusId = object.nucleusId ?? 0;
    message.personaId = object.personaId ?? 0;
    message.platform = object.platform ?? 0;
    return message;
  },
};

function createBaseTag(): Tag {
  return { tagId: "", priority: 0, metadata: undefined };
}

export const Tag: MessageFns<Tag> = {
  encode(message: Tag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tagId !== "") {
      writer.uint32(10).string(message.tagId);
    }
    if (message.priority !== 0) {
      writer.uint32(16).int32(message.priority);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Tag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tagId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.priority = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Tag>): Tag {
    return Tag.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Tag>): Tag {
    const message = createBaseTag();
    message.tagId = object.tagId ?? "";
    message.priority = object.priority ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseMetadata(): Metadata {
  return { translations: [], resources: [] };
}

export const Metadata: MessageFns<Metadata> = {
  encode(message: Metadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.translations) {
      TranslationMetadata.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.resources) {
      Resource.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Metadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.translations.push(TranslationMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.resources.push(Resource.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Metadata>): Metadata {
    return Metadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Metadata>): Metadata {
    const message = createBaseMetadata();
    message.translations = object.translations?.map((e) => TranslationMetadata.fromPartial(e)) || [];
    message.resources = object.resources?.map((e) => Resource.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTranslationMetadata(): TranslationMetadata {
  return { kind: "", translationId: "" };
}

export const TranslationMetadata: MessageFns<TranslationMetadata> = {
  encode(message: TranslationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.translationId !== "") {
      writer.uint32(18).string(message.translationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TranslationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTranslationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.kind = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.translationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TranslationMetadata>): TranslationMetadata {
    return TranslationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TranslationMetadata>): TranslationMetadata {
    const message = createBaseTranslationMetadata();
    message.kind = object.kind ?? "";
    message.translationId = object.translationId ?? "";
    return message;
  },
};

function createBaseResource(): Resource {
  return { location: undefined, kind: "" };
}

export const Resource: MessageFns<Resource> = {
  encode(message: Resource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.location !== undefined) {
      ResourceLocation.encode(message.location, writer.uint32(10).fork()).join();
    }
    if (message.kind !== "") {
      writer.uint32(18).string(message.kind);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Resource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.location = ResourceLocation.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.kind = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Resource>): Resource {
    return Resource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Resource>): Resource {
    const message = createBaseResource();
    message.location = (object.location !== undefined && object.location !== null)
      ? ResourceLocation.fromPartial(object.location)
      : undefined;
    message.kind = object.kind ?? "";
    return message;
  },
};

function createBaseResourceLocation(): ResourceLocation {
  return { ref: undefined, url: undefined };
}

export const ResourceLocation: MessageFns<ResourceLocation> = {
  encode(message: ResourceLocation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ref !== undefined) {
      writer.uint32(10).string(message.ref);
    }
    if (message.url !== undefined) {
      writer.uint32(18).string(message.url);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceLocation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceLocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ref = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ResourceLocation>): ResourceLocation {
    return ResourceLocation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResourceLocation>): ResourceLocation {
    const message = createBaseResourceLocation();
    message.ref = object.ref ?? undefined;
    message.url = object.url ?? undefined;
    return message;
  },
};

function createBaseAttachment(): Attachment {
  return {
    id: "",
    version: "",
    filename: undefined,
    isProcessable: false,
    processingStatus: 0,
    attachmentData: undefined,
    attachmentType: 0,
    metadata: undefined,
    errors: [],
  };
}

export const Attachment: MessageFns<Attachment> = {
  encode(message: Attachment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.filename !== undefined) {
      writer.uint32(26).string(message.filename);
    }
    if (message.isProcessable !== false) {
      writer.uint32(32).bool(message.isProcessable);
    }
    if (message.processingStatus !== 0) {
      writer.uint32(40).int32(message.processingStatus);
    }
    if (message.attachmentData !== undefined) {
      AttachmentData.encode(message.attachmentData, writer.uint32(50).fork()).join();
    }
    if (message.attachmentType !== 0) {
      writer.uint32(56).int32(message.attachmentType);
    }
    if (message.metadata !== undefined) {
      writer.uint32(66).string(message.metadata);
    }
    for (const v of message.errors) {
      writer.uint32(74).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Attachment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttachment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.filename = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isProcessable = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.processingStatus = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.attachmentData = AttachmentData.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.attachmentType = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.errors.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Attachment>): Attachment {
    return Attachment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Attachment>): Attachment {
    const message = createBaseAttachment();
    message.id = object.id ?? "";
    message.version = object.version ?? "";
    message.filename = object.filename ?? undefined;
    message.isProcessable = object.isProcessable ?? false;
    message.processingStatus = object.processingStatus ?? 0;
    message.attachmentData = (object.attachmentData !== undefined && object.attachmentData !== null)
      ? AttachmentData.fromPartial(object.attachmentData)
      : undefined;
    message.attachmentType = object.attachmentType ?? 0;
    message.metadata = object.metadata ?? undefined;
    message.errors = object.errors?.map((e) => e) || [];
    return message;
  },
};

function createBasePlayElementSettings(): PlayElementSettings {
  return { secret: undefined, messages: [], allowCopies: false };
}

export const PlayElementSettings: MessageFns<PlayElementSettings> = {
  encode(message: PlayElementSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.secret !== undefined) {
      writer.uint32(10).string(message.secret);
    }
    for (const v of message.messages) {
      GameServerMessage.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.allowCopies !== false) {
      writer.uint32(24).bool(message.allowCopies);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayElementSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayElementSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.secret = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.messages.push(GameServerMessage.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.allowCopies = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PlayElementSettings>): PlayElementSettings {
    return PlayElementSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlayElementSettings>): PlayElementSettings {
    const message = createBasePlayElementSettings();
    message.secret = object.secret ?? undefined;
    message.messages = object.messages?.map((e) => GameServerMessage.fromPartial(e)) || [];
    message.allowCopies = object.allowCopies ?? false;
    return message;
  },
};

function createBaseGameServerMessage(): GameServerMessage {
  return { kind: "", text: "" };
}

export const GameServerMessage: MessageFns<GameServerMessage> = {
  encode(message: GameServerMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.text !== "") {
      writer.uint32(18).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameServerMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameServerMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.kind = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.text = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GameServerMessage>): GameServerMessage {
    return GameServerMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GameServerMessage>): GameServerMessage {
    const message = createBaseGameServerMessage();
    message.kind = object.kind ?? "";
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseDesignMetadata(): DesignMetadata {
  return { progressionMode: undefined, firstPartyMetadata: [] };
}

export const DesignMetadata: MessageFns<DesignMetadata> = {
  encode(message: DesignMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.progressionMode !== undefined) {
      writer.uint32(10).string(message.progressionMode);
    }
    for (const v of message.firstPartyMetadata) {
      FirstPartyMetadata.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DesignMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDesignMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.progressionMode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.firstPartyMetadata.push(FirstPartyMetadata.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<DesignMetadata>): DesignMetadata {
    return DesignMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DesignMetadata>): DesignMetadata {
    const message = createBaseDesignMetadata();
    message.progressionMode = object.progressionMode ?? undefined;
    message.firstPartyMetadata = object.firstPartyMetadata?.map((e) => FirstPartyMetadata.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFirstPartyMetadata(): FirstPartyMetadata {
  return { psnMetadata: undefined };
}

export const FirstPartyMetadata: MessageFns<FirstPartyMetadata> = {
  encode(message: FirstPartyMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.psnMetadata !== undefined) {
      PSNMetadata.encode(message.psnMetadata, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FirstPartyMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFirstPartyMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.psnMetadata = PSNMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<FirstPartyMetadata>): FirstPartyMetadata {
    return FirstPartyMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FirstPartyMetadata>): FirstPartyMetadata {
    const message = createBaseFirstPartyMetadata();
    message.psnMetadata = (object.psnMetadata !== undefined && object.psnMetadata !== null)
      ? PSNMetadata.fromPartial(object.psnMetadata)
      : undefined;
    return message;
  },
};

function createBasePSNMetadata(): PSNMetadata {
  return { activityId: "" };
}

export const PSNMetadata: MessageFns<PSNMetadata> = {
  encode(message: PSNMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.activityId !== "") {
      writer.uint32(10).string(message.activityId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PSNMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePSNMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.activityId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PSNMetadata>): PSNMetadata {
    return PSNMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PSNMetadata>): PSNMetadata {
    const message = createBasePSNMetadata();
    message.activityId = object.activityId ?? "";
    return message;
  },
};

function createBaseMapRotation(): MapRotation {
  return { maps: [], attributes: undefined };
}

export const MapRotation: MessageFns<MapRotation> = {
  encode(message: MapRotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.maps) {
      MapEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.attributes !== undefined) {
      MapRotationAttributes.encode(message.attributes, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapRotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapRotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.maps.push(MapEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.attributes = MapRotationAttributes.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<MapRotation>): MapRotation {
    return MapRotation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapRotation>): MapRotation {
    const message = createBaseMapRotation();
    message.maps = object.maps?.map((e) => MapEntry.fromPartial(e)) || [];
    message.attributes = (object.attributes !== undefined && object.attributes !== null)
      ? MapRotationAttributes.fromPartial(object.attributes)
      : undefined;
    return message;
  },
};

function createBaseMapEntry(): MapEntry {
  return {
    levelName: "",
    levelLocation: "",
    rounds: 0,
    allowedSpectators: 0,
    teamComposition: undefined,
    blazeGameSettings: undefined,
    mutators: [],
    gameServerJoinabilitySettings: undefined,
  };
}

export const MapEntry: MessageFns<MapEntry> = {
  encode(message: MapEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.levelName !== "") {
      writer.uint32(10).string(message.levelName);
    }
    if (message.levelLocation !== "") {
      writer.uint32(18).string(message.levelLocation);
    }
    if (message.rounds !== 0) {
      writer.uint32(24).int32(message.rounds);
    }
    if (message.allowedSpectators !== 0) {
      writer.uint32(32).int32(message.allowedSpectators);
    }
    if (message.teamComposition !== undefined) {
      TeamComposition.encode(message.teamComposition, writer.uint32(42).fork()).join();
    }
    if (message.blazeGameSettings !== undefined) {
      BlazeGameSettings.encode(message.blazeGameSettings, writer.uint32(50).fork()).join();
    }
    for (const v of message.mutators) {
      Mutator.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.gameServerJoinabilitySettings !== undefined) {
      GameServerJoinabilitySettings.encode(message.gameServerJoinabilitySettings, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.levelName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.levelLocation = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rounds = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.allowedSpectators = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.teamComposition = TeamComposition.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.blazeGameSettings = BlazeGameSettings.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.mutators.push(Mutator.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.gameServerJoinabilitySettings = GameServerJoinabilitySettings.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<MapEntry>): MapEntry {
    return MapEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapEntry>): MapEntry {
    const message = createBaseMapEntry();
    message.levelName = object.levelName ?? "";
    message.levelLocation = object.levelLocation ?? "";
    message.rounds = object.rounds ?? 0;
    message.allowedSpectators = object.allowedSpectators ?? 0;
    message.teamComposition = (object.teamComposition !== undefined && object.teamComposition !== null)
      ? TeamComposition.fromPartial(object.teamComposition)
      : undefined;
    message.blazeGameSettings = (object.blazeGameSettings !== undefined && object.blazeGameSettings !== null)
      ? BlazeGameSettings.fromPartial(object.blazeGameSettings)
      : undefined;
    message.mutators = object.mutators?.map((e) => Mutator.fromPartial(e)) || [];
    message.gameServerJoinabilitySettings =
      (object.gameServerJoinabilitySettings !== undefined && object.gameServerJoinabilitySettings !== null)
        ? GameServerJoinabilitySettings.fromPartial(object.gameServerJoinabilitySettings)
        : undefined;
    return message;
  },
};

function createBaseBlazeGameSettings(): BlazeGameSettings {
  return { joinInProgress: 0, openToJoinByPlayer: 0, openToInvites: 0 };
}

export const BlazeGameSettings: MessageFns<BlazeGameSettings> = {
  encode(message: BlazeGameSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.joinInProgress !== 0) {
      writer.uint32(8).int32(message.joinInProgress);
    }
    if (message.openToJoinByPlayer !== 0) {
      writer.uint32(16).int32(message.openToJoinByPlayer);
    }
    if (message.openToInvites !== 0) {
      writer.uint32(24).int32(message.openToInvites);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlazeGameSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlazeGameSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.joinInProgress = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.openToJoinByPlayer = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.openToInvites = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<BlazeGameSettings>): BlazeGameSettings {
    return BlazeGameSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlazeGameSettings>): BlazeGameSettings {
    const message = createBaseBlazeGameSettings();
    message.joinInProgress = object.joinInProgress ?? 0;
    message.openToJoinByPlayer = object.openToJoinByPlayer ?? 0;
    message.openToInvites = object.openToInvites ?? 0;
    return message;
  },
};

function createBaseGameServerJoinabilitySettings(): GameServerJoinabilitySettings {
  return { matchmakingInProgress: 0 };
}

export const GameServerJoinabilitySettings: MessageFns<GameServerJoinabilitySettings> = {
  encode(message: GameServerJoinabilitySettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.matchmakingInProgress !== 0) {
      writer.uint32(8).int32(message.matchmakingInProgress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameServerJoinabilitySettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameServerJoinabilitySettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.matchmakingInProgress = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GameServerJoinabilitySettings>): GameServerJoinabilitySettings {
    return GameServerJoinabilitySettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GameServerJoinabilitySettings>): GameServerJoinabilitySettings {
    const message = createBaseGameServerJoinabilitySettings();
    message.matchmakingInProgress = object.matchmakingInProgress ?? 0;
    return message;
  },
};

function createBaseMapRotationAttributes(): MapRotationAttributes {
  return { rotationBehavior: 0 };
}

export const MapRotationAttributes: MessageFns<MapRotationAttributes> = {
  encode(message: MapRotationAttributes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rotationBehavior !== 0) {
      writer.uint32(8).int32(message.rotationBehavior);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapRotationAttributes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapRotationAttributes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.rotationBehavior = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<MapRotationAttributes>): MapRotationAttributes {
    return MapRotationAttributes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapRotationAttributes>): MapRotationAttributes {
    const message = createBaseMapRotationAttributes();
    message.rotationBehavior = object.rotationBehavior ?? 0;
    return message;
  },
};

function createBaseModRules(): ModRules {
  return { compatibleRules: undefined, incompatibleRules: undefined, errorRules: undefined };
}

export const ModRules: MessageFns<ModRules> = {
  encode(message: ModRules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.compatibleRules !== undefined) {
      CompatibleModRules.encode(message.compatibleRules, writer.uint32(10).fork()).join();
    }
    if (message.incompatibleRules !== undefined) {
      IncompatibleModRules.encode(message.incompatibleRules, writer.uint32(18).fork()).join();
    }
    if (message.errorRules !== undefined) {
      ErrorModRules.encode(message.errorRules, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModRules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModRules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.compatibleRules = CompatibleModRules.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.incompatibleRules = IncompatibleModRules.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.errorRules = ErrorModRules.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ModRules>): ModRules {
    return ModRules.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ModRules>): ModRules {
    const message = createBaseModRules();
    message.compatibleRules = (object.compatibleRules !== undefined && object.compatibleRules !== null)
      ? CompatibleModRules.fromPartial(object.compatibleRules)
      : undefined;
    message.incompatibleRules = (object.incompatibleRules !== undefined && object.incompatibleRules !== null)
      ? IncompatibleModRules.fromPartial(object.incompatibleRules)
      : undefined;
    message.errorRules = (object.errorRules !== undefined && object.errorRules !== null)
      ? ErrorModRules.fromPartial(object.errorRules)
      : undefined;
    return message;
  },
};

function createBaseBlazePlayElementDesignSettings(): BlazePlayElementDesignSettings {
  return { openGroupReservations: 0 };
}

export const BlazePlayElementDesignSettings: MessageFns<BlazePlayElementDesignSettings> = {
  encode(message: BlazePlayElementDesignSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.openGroupReservations !== 0) {
      writer.uint32(8).int32(message.openGroupReservations);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlazePlayElementDesignSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlazePlayElementDesignSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.openGroupReservations = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<BlazePlayElementDesignSettings>): BlazePlayElementDesignSettings {
    return BlazePlayElementDesignSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlazePlayElementDesignSettings>): BlazePlayElementDesignSettings {
    const message = createBaseBlazePlayElementDesignSettings();
    message.openGroupReservations = object.openGroupReservations ?? 0;
    return message;
  },
};

function createBaseAttachmentData(): AttachmentData {
  return { original: new Uint8Array(0), compiled: undefined };
}

export const AttachmentData: MessageFns<AttachmentData> = {
  encode(message: AttachmentData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.original.length !== 0) {
      writer.uint32(10).bytes(message.original);
    }
    if (message.compiled !== undefined) {
      writer.uint32(18).bytes(message.compiled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttachmentData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttachmentData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.original = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.compiled = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AttachmentData>): AttachmentData {
    return AttachmentData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AttachmentData>): AttachmentData {
    const message = createBaseAttachmentData();
    message.original = object.original ?? new Uint8Array(0);
    message.compiled = object.compiled ?? undefined;
    return message;
  },
};

function createBaseTeamComposition(): TeamComposition {
  return { teams: [], internalTeams: [], balancingMethod: 0 };
}

export const TeamComposition: MessageFns<TeamComposition> = {
  encode(message: TeamComposition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.teams) {
      TeamStructure.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.internalTeams) {
      InternalTeamStructure.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.balancingMethod !== 0) {
      writer.uint32(24).int32(message.balancingMethod);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TeamComposition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTeamComposition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.teams.push(TeamStructure.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.internalTeams.push(InternalTeamStructure.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.balancingMethod = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TeamComposition>): TeamComposition {
    return TeamComposition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TeamComposition>): TeamComposition {
    const message = createBaseTeamComposition();
    message.teams = object.teams?.map((e) => TeamStructure.fromPartial(e)) || [];
    message.internalTeams = object.internalTeams?.map((e) => InternalTeamStructure.fromPartial(e)) || [];
    message.balancingMethod = object.balancingMethod ?? 0;
    return message;
  },
};

function createBaseTeamStructure(): TeamStructure {
  return { teamId: 0, capacity: 0 };
}

export const TeamStructure: MessageFns<TeamStructure> = {
  encode(message: TeamStructure, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.teamId !== 0) {
      writer.uint32(8).int32(message.teamId);
    }
    if (message.capacity !== 0) {
      writer.uint32(16).int32(message.capacity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TeamStructure {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTeamStructure();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.teamId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.capacity = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TeamStructure>): TeamStructure {
    return TeamStructure.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TeamStructure>): TeamStructure {
    const message = createBaseTeamStructure();
    message.teamId = object.teamId ?? 0;
    message.capacity = object.capacity ?? 0;
    return message;
  },
};

function createBaseInternalTeamStructure(): InternalTeamStructure {
  return { teamId: 0, capacity: 0, capacityType: 0 };
}

export const InternalTeamStructure: MessageFns<InternalTeamStructure> = {
  encode(message: InternalTeamStructure, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.teamId !== 0) {
      writer.uint32(8).int32(message.teamId);
    }
    if (message.capacity !== 0) {
      writer.uint32(16).int32(message.capacity);
    }
    if (message.capacityType !== 0) {
      writer.uint32(24).int32(message.capacityType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InternalTeamStructure {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInternalTeamStructure();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.teamId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.capacity = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.capacityType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<InternalTeamStructure>): InternalTeamStructure {
    return InternalTeamStructure.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InternalTeamStructure>): InternalTeamStructure {
    const message = createBaseInternalTeamStructure();
    message.teamId = object.teamId ?? 0;
    message.capacity = object.capacity ?? 0;
    message.capacityType = object.capacityType ?? 0;
    return message;
  },
};

function createBaseCompatibleModRules(): CompatibleModRules {
  return { original: new Uint8Array(0), rulesVersion: 0, compiled: undefined };
}

export const CompatibleModRules: MessageFns<CompatibleModRules> = {
  encode(message: CompatibleModRules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.original.length !== 0) {
      writer.uint32(10).bytes(message.original);
    }
    if (message.rulesVersion !== 0) {
      writer.uint32(16).int32(message.rulesVersion);
    }
    if (message.compiled !== undefined) {
      CompiledRules.encode(message.compiled, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompatibleModRules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompatibleModRules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.original = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.rulesVersion = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.compiled = CompiledRules.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<CompatibleModRules>): CompatibleModRules {
    return CompatibleModRules.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CompatibleModRules>): CompatibleModRules {
    const message = createBaseCompatibleModRules();
    message.original = object.original ?? new Uint8Array(0);
    message.rulesVersion = object.rulesVersion ?? 0;
    message.compiled = (object.compiled !== undefined && object.compiled !== null)
      ? CompiledRules.fromPartial(object.compiled)
      : undefined;
    return message;
  },
};

function createBaseCompiledRules(): CompiledRules {
  return { uncompressed: undefined, compressed: undefined };
}

export const CompiledRules: MessageFns<CompiledRules> = {
  encode(message: CompiledRules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uncompressed !== undefined) {
      Uncompressed.encode(message.uncompressed, writer.uint32(10).fork()).join();
    }
    if (message.compressed !== undefined) {
      Compressed.encode(message.compressed, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompiledRules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompiledRules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uncompressed = Uncompressed.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.compressed = Compressed.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<CompiledRules>): CompiledRules {
    return CompiledRules.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CompiledRules>): CompiledRules {
    const message = createBaseCompiledRules();
    message.uncompressed = (object.uncompressed !== undefined && object.uncompressed !== null)
      ? Uncompressed.fromPartial(object.uncompressed)
      : undefined;
    message.compressed = (object.compressed !== undefined && object.compressed !== null)
      ? Compressed.fromPartial(object.compressed)
      : undefined;
    return message;
  },
};

function createBaseUncompressed(): Uncompressed {
  return { compiledModRules: new Uint8Array(0), rulesVersion: 0 };
}

export const Uncompressed: MessageFns<Uncompressed> = {
  encode(message: Uncompressed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.compiledModRules.length !== 0) {
      writer.uint32(10).bytes(message.compiledModRules);
    }
    if (message.rulesVersion !== 0) {
      writer.uint32(16).int32(message.rulesVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Uncompressed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUncompressed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.compiledModRules = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.rulesVersion = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Uncompressed>): Uncompressed {
    return Uncompressed.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Uncompressed>): Uncompressed {
    const message = createBaseUncompressed();
    message.compiledModRules = object.compiledModRules ?? new Uint8Array(0);
    message.rulesVersion = object.rulesVersion ?? 0;
    return message;
  },
};

function createBaseCompressed(): Compressed {
  return { compiledModRules: new Uint8Array(0), rulesVersion: 0, inflatedSize: 0 };
}

export const Compressed: MessageFns<Compressed> = {
  encode(message: Compressed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.compiledModRules.length !== 0) {
      writer.uint32(10).bytes(message.compiledModRules);
    }
    if (message.rulesVersion !== 0) {
      writer.uint32(16).int32(message.rulesVersion);
    }
    if (message.inflatedSize !== 0) {
      writer.uint32(24).int32(message.inflatedSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Compressed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompressed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.compiledModRules = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.rulesVersion = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.inflatedSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Compressed>): Compressed {
    return Compressed.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Compressed>): Compressed {
    const message = createBaseCompressed();
    message.compiledModRules = object.compiledModRules ?? new Uint8Array(0);
    message.rulesVersion = object.rulesVersion ?? 0;
    message.inflatedSize = object.inflatedSize ?? 0;
    return message;
  },
};

function createBaseIncompatibleModRules(): IncompatibleModRules {
  return { original: new Uint8Array(0), rulesVersion: 0, blueprintRulesVersion: 0 };
}

export const IncompatibleModRules: MessageFns<IncompatibleModRules> = {
  encode(message: IncompatibleModRules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.original.length !== 0) {
      writer.uint32(10).bytes(message.original);
    }
    if (message.rulesVersion !== 0) {
      writer.uint32(16).int32(message.rulesVersion);
    }
    if (message.blueprintRulesVersion !== 0) {
      writer.uint32(24).int32(message.blueprintRulesVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IncompatibleModRules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIncompatibleModRules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.original = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.rulesVersion = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.blueprintRulesVersion = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<IncompatibleModRules>): IncompatibleModRules {
    return IncompatibleModRules.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IncompatibleModRules>): IncompatibleModRules {
    const message = createBaseIncompatibleModRules();
    message.original = object.original ?? new Uint8Array(0);
    message.rulesVersion = object.rulesVersion ?? 0;
    message.blueprintRulesVersion = object.blueprintRulesVersion ?? 0;
    return message;
  },
};

function createBaseErrorModRules(): ErrorModRules {
  return { original: new Uint8Array(0), errorMessage: undefined };
}

export const ErrorModRules: MessageFns<ErrorModRules> = {
  encode(message: ErrorModRules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.original.length !== 0) {
      writer.uint32(10).bytes(message.original);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(18).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorModRules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorModRules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.original = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ErrorModRules>): ErrorModRules {
    return ErrorModRules.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ErrorModRules>): ErrorModRules {
    const message = createBaseErrorModRules();
    message.original = object.original ?? new Uint8Array(0);
    message.errorMessage = object.errorMessage ?? undefined;
    return message;
  },
};

function createBaseAssetCategory(): AssetCategory {
  return { tagId: "", boolean: undefined };
}

export const AssetCategory: MessageFns<AssetCategory> = {
  encode(message: AssetCategory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tagId !== "") {
      writer.uint32(10).string(message.tagId);
    }
    if (message.boolean !== undefined) {
      AssetCategoryBoolean.encode(message.boolean, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssetCategory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetCategory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tagId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.boolean = AssetCategoryBoolean.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AssetCategory>): AssetCategory {
    return AssetCategory.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AssetCategory>): AssetCategory {
    const message = createBaseAssetCategory();
    message.tagId = object.tagId ?? "";
    message.boolean = (object.boolean !== undefined && object.boolean !== null)
      ? AssetCategoryBoolean.fromPartial(object.boolean)
      : undefined;
    return message;
  },
};

function createBaseAssetCategoryBoolean(): AssetCategoryBoolean {
  return { defaultValue: false, overrides: undefined, teamOverrides: [] };
}

export const AssetCategoryBoolean: MessageFns<AssetCategoryBoolean> = {
  encode(message: AssetCategoryBoolean, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.defaultValue !== false) {
      writer.uint32(8).bool(message.defaultValue);
    }
    if (message.overrides !== undefined) {
      AssetCategoryTagBooleanOverride.encode(message.overrides, writer.uint32(18).fork()).join();
    }
    for (const v of message.teamOverrides) {
      AssetCategoryTagBooleanTeamOverride.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssetCategoryBoolean {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetCategoryBoolean();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.defaultValue = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.overrides = AssetCategoryTagBooleanOverride.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.teamOverrides.push(AssetCategoryTagBooleanTeamOverride.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AssetCategoryBoolean>): AssetCategoryBoolean {
    return AssetCategoryBoolean.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AssetCategoryBoolean>): AssetCategoryBoolean {
    const message = createBaseAssetCategoryBoolean();
    message.defaultValue = object.defaultValue ?? false;
    message.overrides = (object.overrides !== undefined && object.overrides !== null)
      ? AssetCategoryTagBooleanOverride.fromPartial(object.overrides)
      : undefined;
    message.teamOverrides = object.teamOverrides?.map((e) => AssetCategoryTagBooleanTeamOverride.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAssetCategoryTagBooleanOverride(): AssetCategoryTagBooleanOverride {
  return { assetCategoryTags: [], value: false };
}

export const AssetCategoryTagBooleanOverride: MessageFns<AssetCategoryTagBooleanOverride> = {
  encode(message: AssetCategoryTagBooleanOverride, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.assetCategoryTags) {
      writer.uint32(10).string(v!);
    }
    if (message.value !== false) {
      writer.uint32(16).bool(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssetCategoryTagBooleanOverride {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetCategoryTagBooleanOverride();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.assetCategoryTags.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AssetCategoryTagBooleanOverride>): AssetCategoryTagBooleanOverride {
    return AssetCategoryTagBooleanOverride.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AssetCategoryTagBooleanOverride>): AssetCategoryTagBooleanOverride {
    const message = createBaseAssetCategoryTagBooleanOverride();
    message.assetCategoryTags = object.assetCategoryTags?.map((e) => e) || [];
    message.value = object.value ?? false;
    return message;
  },
};

function createBaseAssetCategoryTagBooleanTeamOverride(): AssetCategoryTagBooleanTeamOverride {
  return { assetCategoryTags: [], value: false, teamId: 0 };
}

export const AssetCategoryTagBooleanTeamOverride: MessageFns<AssetCategoryTagBooleanTeamOverride> = {
  encode(message: AssetCategoryTagBooleanTeamOverride, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.assetCategoryTags) {
      writer.uint32(10).string(v!);
    }
    if (message.value !== false) {
      writer.uint32(16).bool(message.value);
    }
    if (message.teamId !== 0) {
      writer.uint32(24).int32(message.teamId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssetCategoryTagBooleanTeamOverride {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetCategoryTagBooleanTeamOverride();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.assetCategoryTags.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.teamId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AssetCategoryTagBooleanTeamOverride>): AssetCategoryTagBooleanTeamOverride {
    return AssetCategoryTagBooleanTeamOverride.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AssetCategoryTagBooleanTeamOverride>): AssetCategoryTagBooleanTeamOverride {
    const message = createBaseAssetCategoryTagBooleanTeamOverride();
    message.assetCategoryTags = object.assetCategoryTags?.map((e) => e) || [];
    message.value = object.value ?? false;
    message.teamId = object.teamId ?? 0;
    return message;
  },
};

function createBaseMutator(): Mutator {
  return { name: "", category: "", kind: undefined, id: "" };
}

export const Mutator: MessageFns<Mutator> = {
  encode(message: Mutator, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.category !== "") {
      writer.uint32(18).string(message.category);
    }
    if (message.kind !== undefined) {
      MutatorKind.encode(message.kind, writer.uint32(26).fork()).join();
    }
    if (message.id !== "") {
      writer.uint32(34).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Mutator {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.kind = MutatorKind.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Mutator>): Mutator {
    return Mutator.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Mutator>): Mutator {
    const message = createBaseMutator();
    message.name = object.name ?? "";
    message.category = object.category ?? "";
    message.kind = (object.kind !== undefined && object.kind !== null)
      ? MutatorKind.fromPartial(object.kind)
      : undefined;
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseMutatorKind(): MutatorKind {
  return {
    mutatorBoolean: undefined,
    mutatorString: undefined,
    mutatorFloat: undefined,
    mutatorInt: undefined,
    mutatorSparseBoolean: undefined,
    mutatorSparseInt: undefined,
    mutatorSparseFloat: undefined,
  };
}

export const MutatorKind: MessageFns<MutatorKind> = {
  encode(message: MutatorKind, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mutatorBoolean !== undefined) {
      MutatorBoolean.encode(message.mutatorBoolean, writer.uint32(10).fork()).join();
    }
    if (message.mutatorString !== undefined) {
      MutatorString.encode(message.mutatorString, writer.uint32(34).fork()).join();
    }
    if (message.mutatorFloat !== undefined) {
      MutatorFloat.encode(message.mutatorFloat, writer.uint32(42).fork()).join();
    }
    if (message.mutatorInt !== undefined) {
      MutatorInt.encode(message.mutatorInt, writer.uint32(50).fork()).join();
    }
    if (message.mutatorSparseBoolean !== undefined) {
      MutatorSparseBoolean.encode(message.mutatorSparseBoolean, writer.uint32(58).fork()).join();
    }
    if (message.mutatorSparseInt !== undefined) {
      MutatorSparseInt.encode(message.mutatorSparseInt, writer.uint32(66).fork()).join();
    }
    if (message.mutatorSparseFloat !== undefined) {
      MutatorSparseFloat.encode(message.mutatorSparseFloat, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MutatorKind {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutatorKind();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mutatorBoolean = MutatorBoolean.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.mutatorString = MutatorString.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.mutatorFloat = MutatorFloat.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.mutatorInt = MutatorInt.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.mutatorSparseBoolean = MutatorSparseBoolean.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.mutatorSparseInt = MutatorSparseInt.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.mutatorSparseFloat = MutatorSparseFloat.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<MutatorKind>): MutatorKind {
    return MutatorKind.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MutatorKind>): MutatorKind {
    const message = createBaseMutatorKind();
    message.mutatorBoolean = (object.mutatorBoolean !== undefined && object.mutatorBoolean !== null)
      ? MutatorBoolean.fromPartial(object.mutatorBoolean)
      : undefined;
    message.mutatorString = (object.mutatorString !== undefined && object.mutatorString !== null)
      ? MutatorString.fromPartial(object.mutatorString)
      : undefined;
    message.mutatorFloat = (object.mutatorFloat !== undefined && object.mutatorFloat !== null)
      ? MutatorFloat.fromPartial(object.mutatorFloat)
      : undefined;
    message.mutatorInt = (object.mutatorInt !== undefined && object.mutatorInt !== null)
      ? MutatorInt.fromPartial(object.mutatorInt)
      : undefined;
    message.mutatorSparseBoolean = (object.mutatorSparseBoolean !== undefined && object.mutatorSparseBoolean !== null)
      ? MutatorSparseBoolean.fromPartial(object.mutatorSparseBoolean)
      : undefined;
    message.mutatorSparseInt = (object.mutatorSparseInt !== undefined && object.mutatorSparseInt !== null)
      ? MutatorSparseInt.fromPartial(object.mutatorSparseInt)
      : undefined;
    message.mutatorSparseFloat = (object.mutatorSparseFloat !== undefined && object.mutatorSparseFloat !== null)
      ? MutatorSparseFloat.fromPartial(object.mutatorSparseFloat)
      : undefined;
    return message;
  },
};

function createBaseMutatorBoolean(): MutatorBoolean {
  return { boolValue: false };
}

export const MutatorBoolean: MessageFns<MutatorBoolean> = {
  encode(message: MutatorBoolean, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.boolValue !== false) {
      writer.uint32(8).bool(message.boolValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MutatorBoolean {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutatorBoolean();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.boolValue = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<MutatorBoolean>): MutatorBoolean {
    return MutatorBoolean.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MutatorBoolean>): MutatorBoolean {
    const message = createBaseMutatorBoolean();
    message.boolValue = object.boolValue ?? false;
    return message;
  },
};

function createBaseMutatorString(): MutatorString {
  return { stringValue: "" };
}

export const MutatorString: MessageFns<MutatorString> = {
  encode(message: MutatorString, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stringValue !== "") {
      writer.uint32(10).string(message.stringValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MutatorString {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutatorString();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stringValue = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<MutatorString>): MutatorString {
    return MutatorString.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MutatorString>): MutatorString {
    const message = createBaseMutatorString();
    message.stringValue = object.stringValue ?? "";
    return message;
  },
};

function createBaseMutatorFloat(): MutatorFloat {
  return { value: 0 };
}

export const MutatorFloat: MessageFns<MutatorFloat> = {
  encode(message: MutatorFloat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(13).float(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MutatorFloat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutatorFloat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.value = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<MutatorFloat>): MutatorFloat {
    return MutatorFloat.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MutatorFloat>): MutatorFloat {
    const message = createBaseMutatorFloat();
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseMutatorInt(): MutatorInt {
  return { value: 0 };
}

export const MutatorInt: MessageFns<MutatorInt> = {
  encode(message: MutatorInt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(8).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MutatorInt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutatorInt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<MutatorInt>): MutatorInt {
    return MutatorInt.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MutatorInt>): MutatorInt {
    const message = createBaseMutatorInt();
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseMutatorSparseBooleanEntry(): MutatorSparseBooleanEntry {
  return { index: 0, value: false };
}

export const MutatorSparseBooleanEntry: MessageFns<MutatorSparseBooleanEntry> = {
  encode(message: MutatorSparseBooleanEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== 0) {
      writer.uint32(8).uint32(message.index);
    }
    if (message.value !== false) {
      writer.uint32(16).bool(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MutatorSparseBooleanEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutatorSparseBooleanEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.index = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<MutatorSparseBooleanEntry>): MutatorSparseBooleanEntry {
    return MutatorSparseBooleanEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MutatorSparseBooleanEntry>): MutatorSparseBooleanEntry {
    const message = createBaseMutatorSparseBooleanEntry();
    message.index = object.index ?? 0;
    message.value = object.value ?? false;
    return message;
  },
};

function createBaseMutatorSparseBoolean(): MutatorSparseBoolean {
  return { defaultValue: false, size: 0, sparseValues: [] };
}

export const MutatorSparseBoolean: MessageFns<MutatorSparseBoolean> = {
  encode(message: MutatorSparseBoolean, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.defaultValue !== false) {
      writer.uint32(8).bool(message.defaultValue);
    }
    if (message.size !== 0) {
      writer.uint32(16).uint32(message.size);
    }
    for (const v of message.sparseValues) {
      MutatorSparseBooleanEntry.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MutatorSparseBoolean {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutatorSparseBoolean();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.defaultValue = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.size = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sparseValues.push(MutatorSparseBooleanEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<MutatorSparseBoolean>): MutatorSparseBoolean {
    return MutatorSparseBoolean.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MutatorSparseBoolean>): MutatorSparseBoolean {
    const message = createBaseMutatorSparseBoolean();
    message.defaultValue = object.defaultValue ?? false;
    message.size = object.size ?? 0;
    message.sparseValues = object.sparseValues?.map((e) => MutatorSparseBooleanEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSparseIntEntity(): SparseIntEntity {
  return { values: [] };
}

export const SparseIntEntity: MessageFns<SparseIntEntity> = {
  encode(message: SparseIntEntity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.values) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SparseIntEntity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSparseIntEntity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.values.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.values.push(reader.int32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SparseIntEntity>): SparseIntEntity {
    return SparseIntEntity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SparseIntEntity>): SparseIntEntity {
    const message = createBaseSparseIntEntity();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseMutatorSparseIntEntry(): MutatorSparseIntEntry {
  return { index: 0, value: 0 };
}

export const MutatorSparseIntEntry: MessageFns<MutatorSparseIntEntry> = {
  encode(message: MutatorSparseIntEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== 0) {
      writer.uint32(8).uint32(message.index);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MutatorSparseIntEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutatorSparseIntEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.index = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<MutatorSparseIntEntry>): MutatorSparseIntEntry {
    return MutatorSparseIntEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MutatorSparseIntEntry>): MutatorSparseIntEntry {
    const message = createBaseMutatorSparseIntEntry();
    message.index = object.index ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseMutatorSparseInt(): MutatorSparseInt {
  return { defaultValue: 0, size: 0, sparseValues: undefined };
}

export const MutatorSparseInt: MessageFns<MutatorSparseInt> = {
  encode(message: MutatorSparseInt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.defaultValue !== 0) {
      writer.uint32(8).int32(message.defaultValue);
    }
    if (message.size !== 0) {
      writer.uint32(16).uint32(message.size);
    }
    if (message.sparseValues !== undefined) {
      MutatorSparseIntEntry.encode(message.sparseValues, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MutatorSparseInt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutatorSparseInt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.defaultValue = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.size = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sparseValues = MutatorSparseIntEntry.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<MutatorSparseInt>): MutatorSparseInt {
    return MutatorSparseInt.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MutatorSparseInt>): MutatorSparseInt {
    const message = createBaseMutatorSparseInt();
    message.defaultValue = object.defaultValue ?? 0;
    message.size = object.size ?? 0;
    message.sparseValues = (object.sparseValues !== undefined && object.sparseValues !== null)
      ? MutatorSparseIntEntry.fromPartial(object.sparseValues)
      : undefined;
    return message;
  },
};

function createBaseMutatorSparseFloatEntry(): MutatorSparseFloatEntry {
  return { index: 0, value: 0 };
}

export const MutatorSparseFloatEntry: MessageFns<MutatorSparseFloatEntry> = {
  encode(message: MutatorSparseFloatEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== 0) {
      writer.uint32(8).uint32(message.index);
    }
    if (message.value !== 0) {
      writer.uint32(21).float(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MutatorSparseFloatEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutatorSparseFloatEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.index = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.value = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<MutatorSparseFloatEntry>): MutatorSparseFloatEntry {
    return MutatorSparseFloatEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MutatorSparseFloatEntry>): MutatorSparseFloatEntry {
    const message = createBaseMutatorSparseFloatEntry();
    message.index = object.index ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseMutatorSparseFloat(): MutatorSparseFloat {
  return { defaultValue: 0, size: 0, sparseValues: [] };
}

export const MutatorSparseFloat: MessageFns<MutatorSparseFloat> = {
  encode(message: MutatorSparseFloat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.defaultValue !== 0) {
      writer.uint32(13).float(message.defaultValue);
    }
    if (message.size !== 0) {
      writer.uint32(16).uint32(message.size);
    }
    for (const v of message.sparseValues) {
      MutatorSparseFloatEntry.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MutatorSparseFloat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutatorSparseFloat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.defaultValue = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.size = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sparseValues.push(MutatorSparseFloatEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<MutatorSparseFloat>): MutatorSparseFloat {
    return MutatorSparseFloat.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MutatorSparseFloat>): MutatorSparseFloat {
    const message = createBaseMutatorSparseFloat();
    message.defaultValue = object.defaultValue ?? 0;
    message.size = object.size ?? 0;
    message.sparseValues = object.sparseValues?.map((e) => MutatorSparseFloatEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetPlayElementRequest(): GetPlayElementRequest {
  return { id: "", includeDenied: false };
}

export const GetPlayElementRequest: MessageFns<GetPlayElementRequest> = {
  encode(message: GetPlayElementRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.includeDenied !== false) {
      writer.uint32(16).bool(message.includeDenied);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPlayElementRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPlayElementRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.includeDenied = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetPlayElementRequest>): GetPlayElementRequest {
    return GetPlayElementRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetPlayElementRequest>): GetPlayElementRequest {
    const message = createBaseGetPlayElementRequest();
    message.id = object.id ?? "";
    message.includeDenied = object.includeDenied ?? false;
    return message;
  },
};

function createBaseGetOwnedPlayElementsResponse(): GetOwnedPlayElementsResponse {
  return { playElements: [] };
}

export const GetOwnedPlayElementsResponse: MessageFns<GetOwnedPlayElementsResponse> = {
  encode(message: GetOwnedPlayElementsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.playElements) {
      PlayElement.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOwnedPlayElementsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOwnedPlayElementsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playElements.push(PlayElement.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetOwnedPlayElementsResponse>): GetOwnedPlayElementsResponse {
    return GetOwnedPlayElementsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetOwnedPlayElementsResponse>): GetOwnedPlayElementsResponse {
    const message = createBaseGetOwnedPlayElementsResponse();
    message.playElements = object.playElements?.map((e) => PlayElement.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetOwnedPlayElementsResponseV2(): GetOwnedPlayElementsResponseV2 {
  return { playElements: [] };
}

export const GetOwnedPlayElementsResponseV2: MessageFns<GetOwnedPlayElementsResponseV2> = {
  encode(message: GetOwnedPlayElementsResponseV2, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.playElements) {
      EnrichedPlayElement.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOwnedPlayElementsResponseV2 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOwnedPlayElementsResponseV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playElements.push(EnrichedPlayElement.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetOwnedPlayElementsResponseV2>): GetOwnedPlayElementsResponseV2 {
    return GetOwnedPlayElementsResponseV2.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetOwnedPlayElementsResponseV2>): GetOwnedPlayElementsResponseV2 {
    const message = createBaseGetOwnedPlayElementsResponseV2();
    message.playElements = object.playElements?.map((e) => EnrichedPlayElement.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEnrichedPlayElement(): EnrichedPlayElement {
  return { playElement: undefined, mapRotation: undefined };
}

export const EnrichedPlayElement: MessageFns<EnrichedPlayElement> = {
  encode(message: EnrichedPlayElement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playElement !== undefined) {
      PlayElement.encode(message.playElement, writer.uint32(10).fork()).join();
    }
    if (message.mapRotation !== undefined) {
      MapRotation.encode(message.mapRotation, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnrichedPlayElement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnrichedPlayElement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playElement = PlayElement.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mapRotation = MapRotation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<EnrichedPlayElement>): EnrichedPlayElement {
    return EnrichedPlayElement.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EnrichedPlayElement>): EnrichedPlayElement {
    const message = createBaseEnrichedPlayElement();
    message.playElement = (object.playElement !== undefined && object.playElement !== null)
      ? PlayElement.fromPartial(object.playElement)
      : undefined;
    message.mapRotation = (object.mapRotation !== undefined && object.mapRotation !== null)
      ? MapRotation.fromPartial(object.mapRotation)
      : undefined;
    return message;
  },
};

function createBaseGetOwnedPlayElementsRequest(): GetOwnedPlayElementsRequest {
  return { publishStates: [], includeDenied: false };
}

export const GetOwnedPlayElementsRequest: MessageFns<GetOwnedPlayElementsRequest> = {
  encode(message: GetOwnedPlayElementsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.publishStates) {
      writer.int32(v);
    }
    writer.join();
    if (message.includeDenied !== false) {
      writer.uint32(16).bool(message.includeDenied);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOwnedPlayElementsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOwnedPlayElementsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.publishStates.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.publishStates.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.includeDenied = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetOwnedPlayElementsRequest>): GetOwnedPlayElementsRequest {
    return GetOwnedPlayElementsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetOwnedPlayElementsRequest>): GetOwnedPlayElementsRequest {
    const message = createBaseGetOwnedPlayElementsRequest();
    message.publishStates = object.publishStates?.map((e) => e) || [];
    message.includeDenied = object.includeDenied ?? false;
    return message;
  },
};

export type WebPlayDefinition = typeof WebPlayDefinition;
export const WebPlayDefinition = {
  name: "WebPlay",
  fullName: "santiago.web.play.WebPlay",
  methods: {
    createPlayElement: {
      name: "createPlayElement",
      requestType: CreatePlayElementRequest,
      requestStream: false,
      responseType: PlayElementResponse,
      responseStream: false,
      options: {},
    },
    getPlayElement: {
      name: "getPlayElement",
      requestType: GetPlayElementRequest,
      requestStream: false,
      responseType: PlayElementResponse,
      responseStream: false,
      options: {},
    },
    updatePlayElement: {
      name: "updatePlayElement",
      requestType: UpdatePlayElementRequest,
      requestStream: false,
      responseType: PlayElementResponse,
      responseStream: false,
      options: {},
    },
    deletePlayElement: {
      name: "deletePlayElement",
      requestType: DeletePlayElementRequest,
      requestStream: false,
      responseType: DeletePlayElementResponse,
      responseStream: false,
      options: {},
    },
    getOwnedPlayElements: {
      name: "getOwnedPlayElements",
      requestType: GetOwnedPlayElementsRequest,
      requestStream: false,
      responseType: GetOwnedPlayElementsResponse,
      responseStream: false,
      options: {},
    },
    getOwnedPlayElementsV2: {
      name: "getOwnedPlayElementsV2",
      requestType: GetOwnedPlayElementsRequest,
      requestStream: false,
      responseType: GetOwnedPlayElementsResponseV2,
      responseStream: false,
      options: {},
    },
    getBlueprintsById: {
      name: "getBlueprintsById",
      requestType: GetBlueprintsByIdRequest,
      requestStream: false,
      responseType: GetBlueprintsByIdResponse,
      responseStream: false,
      options: {},
    },
    getScheduledBlueprints: {
      name: "getScheduledBlueprints",
      requestType: GetScheduledBlueprintsRequest,
      requestStream: false,
      responseType: GetScheduledBlueprintsResponse,
      responseStream: false,
      options: {},
    },
    createModDataVersion: {
      name: "createModDataVersion",
      requestType: CreateModDataVersionRequest,
      requestStream: false,
      responseType: CreateModDataVersionResponse,
      responseStream: false,
      options: {},
    },
    listModDataVersions: {
      name: "listModDataVersions",
      requestType: ListModDataVersionsRequest,
      requestStream: false,
      responseType: ListModDataVersionsResponse,
      responseStream: false,
      options: {},
    },
    uploadExperienceThumbnail: {
      name: "UploadExperienceThumbnail",
      requestType: UploadExperienceThumbnailRequest,
      requestStream: false,
      responseType: UploadExperienceThumbnailResponse,
      responseStream: false,
      options: {},
    },
    getProgressionTypes: {
      name: "GetProgressionTypes",
      requestType: GetProgressionTypesRequest,
      requestStream: false,
      responseType: GetProgressionTypesResponse,
      responseStream: false,
      options: {},
    },
    getLicenseRequirements: {
      name: "GetLicenseRequirements",
      requestType: GetLicenseRequirementsRequest,
      requestStream: false,
      responseType: GetLicenseRequirementsResponse,
      responseStream: false,
      options: {},
    },
    getAvailableTags: {
      name: "GetAvailableTags",
      requestType: GetAvailableTagsRequest,
      requestStream: false,
      responseType: GetAvailableTagsResponse,
      responseStream: false,
      options: {},
    },
    listExperiences: {
      name: "ListExperiences",
      requestType: ListExperiencesRequest,
      requestStream: false,
      responseType: ListExperiencesResponse,
      responseStream: false,
      options: {},
    },
    deleteAttachments: {
      name: "DeleteAttachments",
      requestType: DeleteAttachmentsRequest,
      requestStream: false,
      responseType: DeleteAttachmentsResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface WebPlayServiceImplementation<CallContextExt = {}> {
  createPlayElement(
    request: CreatePlayElementRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<PlayElementResponse>>;
  getPlayElement(
    request: GetPlayElementRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<PlayElementResponse>>;
  updatePlayElement(
    request: UpdatePlayElementRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<PlayElementResponse>>;
  deletePlayElement(
    request: DeletePlayElementRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<DeletePlayElementResponse>>;
  getOwnedPlayElements(
    request: GetOwnedPlayElementsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetOwnedPlayElementsResponse>>;
  getOwnedPlayElementsV2(
    request: GetOwnedPlayElementsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetOwnedPlayElementsResponseV2>>;
  getBlueprintsById(
    request: GetBlueprintsByIdRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetBlueprintsByIdResponse>>;
  getScheduledBlueprints(
    request: GetScheduledBlueprintsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetScheduledBlueprintsResponse>>;
  createModDataVersion(
    request: CreateModDataVersionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CreateModDataVersionResponse>>;
  listModDataVersions(
    request: ListModDataVersionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListModDataVersionsResponse>>;
  uploadExperienceThumbnail(
    request: UploadExperienceThumbnailRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<UploadExperienceThumbnailResponse>>;
  getProgressionTypes(
    request: GetProgressionTypesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetProgressionTypesResponse>>;
  getLicenseRequirements(
    request: GetLicenseRequirementsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetLicenseRequirementsResponse>>;
  getAvailableTags(
    request: GetAvailableTagsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetAvailableTagsResponse>>;
  listExperiences(
    request: ListExperiencesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListExperiencesResponse>>;
  deleteAttachments(
    request: DeleteAttachmentsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<DeleteAttachmentsResponse>>;
}

export interface WebPlayClient<CallOptionsExt = {}> {
  createPlayElement(
    request: DeepPartial<CreatePlayElementRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<PlayElementResponse>;
  getPlayElement(
    request: DeepPartial<GetPlayElementRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<PlayElementResponse>;
  updatePlayElement(
    request: DeepPartial<UpdatePlayElementRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<PlayElementResponse>;
  deletePlayElement(
    request: DeepPartial<DeletePlayElementRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DeletePlayElementResponse>;
  getOwnedPlayElements(
    request: DeepPartial<GetOwnedPlayElementsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetOwnedPlayElementsResponse>;
  getOwnedPlayElementsV2(
    request: DeepPartial<GetOwnedPlayElementsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetOwnedPlayElementsResponseV2>;
  getBlueprintsById(
    request: DeepPartial<GetBlueprintsByIdRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetBlueprintsByIdResponse>;
  getScheduledBlueprints(
    request: DeepPartial<GetScheduledBlueprintsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetScheduledBlueprintsResponse>;
  createModDataVersion(
    request: DeepPartial<CreateModDataVersionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CreateModDataVersionResponse>;
  listModDataVersions(
    request: DeepPartial<ListModDataVersionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListModDataVersionsResponse>;
  uploadExperienceThumbnail(
    request: DeepPartial<UploadExperienceThumbnailRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<UploadExperienceThumbnailResponse>;
  getProgressionTypes(
    request: DeepPartial<GetProgressionTypesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetProgressionTypesResponse>;
  getLicenseRequirements(
    request: DeepPartial<GetLicenseRequirementsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetLicenseRequirementsResponse>;
  getAvailableTags(
    request: DeepPartial<GetAvailableTagsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetAvailableTagsResponse>;
  listExperiences(
    request: DeepPartial<ListExperiencesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListExperiencesResponse>;
  deleteAttachments(
    request: DeepPartial<DeleteAttachmentsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DeleteAttachmentsResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
