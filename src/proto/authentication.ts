// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v3.19.1
// source: authentication.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { CallContext, CallOptions } from "nice-grpc-common";

export const protobufPackage = "santiago.web.authentication";

export enum Platform {
  UNKNOWN = 0,
  /** PC - PC - EA App */
  PC = 1,
  PS4 = 2,
  XBOXONE = 3,
  PS5 = 4,
  XBSX = 5,
  /** COMMON - COMMON - Used for requests that includes a cross-platform payload */
  COMMON = 6,
  STEAM = 7,
  UNRECOGNIZED = -1,
}

export enum Reason {
  NONE = 0,
  SYNC = 1,
  UNRECOGNIZED = -1,
}

export interface Player {
  nucleusId: number;
  personaId: number;
  platform: Platform;
}

export interface MutatorString {
  stringValue: string;
}

export interface AuthCodeAuthentication {
  authCode: string;
  platform: Platform;
  redirectUri?: MutatorString | undefined;
  patchVersion?: string | undefined;
  protocolVersion?: string | undefined;
}

export interface Duration {
  seconds: number;
  nanos: number;
}

export interface TimeTravel {
  offset: Duration | undefined;
}

export interface ProtocolVersionOverride {
  original: string;
  overridden: string;
  reason: Reason;
}

export interface Empty {
}

export interface AuthenticationResponse {
  sessionId: string;
  player?: Player | undefined;
  timeTravel?: TimeTravel | undefined;
  protocolVersionOverride?: ProtocolVersionOverride | undefined;
  patchVersion: string;
}

function createBasePlayer(): Player {
  return { nucleusId: 0, personaId: 0, platform: 0 };
}

export const Player: MessageFns<Player> = {
  encode(message: Player, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nucleusId !== 0) {
      writer.uint32(8).int64(message.nucleusId);
    }
    if (message.personaId !== 0) {
      writer.uint32(16).int64(message.personaId);
    }
    if (message.platform !== 0) {
      writer.uint32(24).int32(message.platform);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Player {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.nucleusId = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.personaId = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.platform = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Player>): Player {
    return Player.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Player>): Player {
    const message = createBasePlayer();
    message.nucleusId = object.nucleusId ?? 0;
    message.personaId = object.personaId ?? 0;
    message.platform = object.platform ?? 0;
    return message;
  },
};

function createBaseMutatorString(): MutatorString {
  return { stringValue: "" };
}

export const MutatorString: MessageFns<MutatorString> = {
  encode(message: MutatorString, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stringValue !== "") {
      writer.uint32(10).string(message.stringValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MutatorString {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutatorString();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stringValue = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<MutatorString>): MutatorString {
    return MutatorString.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MutatorString>): MutatorString {
    const message = createBaseMutatorString();
    message.stringValue = object.stringValue ?? "";
    return message;
  },
};

function createBaseAuthCodeAuthentication(): AuthCodeAuthentication {
  return { authCode: "", platform: 0, redirectUri: undefined, patchVersion: undefined, protocolVersion: undefined };
}

export const AuthCodeAuthentication: MessageFns<AuthCodeAuthentication> = {
  encode(message: AuthCodeAuthentication, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authCode !== "") {
      writer.uint32(10).string(message.authCode);
    }
    if (message.platform !== 0) {
      writer.uint32(16).int32(message.platform);
    }
    if (message.redirectUri !== undefined) {
      MutatorString.encode(message.redirectUri, writer.uint32(26).fork()).join();
    }
    if (message.patchVersion !== undefined) {
      writer.uint32(34).string(message.patchVersion);
    }
    if (message.protocolVersion !== undefined) {
      writer.uint32(42).string(message.protocolVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthCodeAuthentication {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthCodeAuthentication();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.platform = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.redirectUri = MutatorString.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.patchVersion = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.protocolVersion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AuthCodeAuthentication>): AuthCodeAuthentication {
    return AuthCodeAuthentication.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AuthCodeAuthentication>): AuthCodeAuthentication {
    const message = createBaseAuthCodeAuthentication();
    message.authCode = object.authCode ?? "";
    message.platform = object.platform ?? 0;
    message.redirectUri = (object.redirectUri !== undefined && object.redirectUri !== null)
      ? MutatorString.fromPartial(object.redirectUri)
      : undefined;
    message.patchVersion = object.patchVersion ?? undefined;
    message.protocolVersion = object.protocolVersion ?? undefined;
    return message;
  },
};

function createBaseDuration(): Duration {
  return { seconds: 0, nanos: 0 };
}

export const Duration: MessageFns<Duration> = {
  encode(message: Duration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.seconds !== 0) {
      writer.uint32(8).int64(message.seconds);
    }
    if (message.nanos !== 0) {
      writer.uint32(16).int32(message.nanos);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Duration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDuration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.seconds = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.nanos = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Duration>): Duration {
    return Duration.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Duration>): Duration {
    const message = createBaseDuration();
    message.seconds = object.seconds ?? 0;
    message.nanos = object.nanos ?? 0;
    return message;
  },
};

function createBaseTimeTravel(): TimeTravel {
  return { offset: undefined };
}

export const TimeTravel: MessageFns<TimeTravel> = {
  encode(message: TimeTravel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.offset !== undefined) {
      Duration.encode(message.offset, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeTravel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeTravel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.offset = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TimeTravel>): TimeTravel {
    return TimeTravel.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TimeTravel>): TimeTravel {
    const message = createBaseTimeTravel();
    message.offset = (object.offset !== undefined && object.offset !== null)
      ? Duration.fromPartial(object.offset)
      : undefined;
    return message;
  },
};

function createBaseProtocolVersionOverride(): ProtocolVersionOverride {
  return { original: "", overridden: "", reason: 0 };
}

export const ProtocolVersionOverride: MessageFns<ProtocolVersionOverride> = {
  encode(message: ProtocolVersionOverride, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.original !== "") {
      writer.uint32(10).string(message.original);
    }
    if (message.overridden !== "") {
      writer.uint32(18).string(message.overridden);
    }
    if (message.reason !== 0) {
      writer.uint32(24).int32(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtocolVersionOverride {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtocolVersionOverride();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.original = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.overridden = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.reason = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ProtocolVersionOverride>): ProtocolVersionOverride {
    return ProtocolVersionOverride.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProtocolVersionOverride>): ProtocolVersionOverride {
    const message = createBaseProtocolVersionOverride();
    message.original = object.original ?? "";
    message.overridden = object.overridden ?? "";
    message.reason = object.reason ?? 0;
    return message;
  },
};

function createBaseEmpty(): Empty {
  return {};
}

export const Empty: MessageFns<Empty> = {
  encode(_: Empty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Empty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Empty>): Empty {
    return Empty.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Empty>): Empty {
    const message = createBaseEmpty();
    return message;
  },
};

function createBaseAuthenticationResponse(): AuthenticationResponse {
  return {
    sessionId: "",
    player: undefined,
    timeTravel: undefined,
    protocolVersionOverride: undefined,
    patchVersion: "",
  };
}

export const AuthenticationResponse: MessageFns<AuthenticationResponse> = {
  encode(message: AuthenticationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.player !== undefined) {
      Player.encode(message.player, writer.uint32(18).fork()).join();
    }
    if (message.timeTravel !== undefined) {
      TimeTravel.encode(message.timeTravel, writer.uint32(26).fork()).join();
    }
    if (message.protocolVersionOverride !== undefined) {
      ProtocolVersionOverride.encode(message.protocolVersionOverride, writer.uint32(34).fork()).join();
    }
    if (message.patchVersion !== "") {
      writer.uint32(42).string(message.patchVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthenticationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthenticationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.player = Player.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timeTravel = TimeTravel.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.protocolVersionOverride = ProtocolVersionOverride.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.patchVersion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AuthenticationResponse>): AuthenticationResponse {
    return AuthenticationResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AuthenticationResponse>): AuthenticationResponse {
    const message = createBaseAuthenticationResponse();
    message.sessionId = object.sessionId ?? "";
    message.player = (object.player !== undefined && object.player !== null)
      ? Player.fromPartial(object.player)
      : undefined;
    message.timeTravel = (object.timeTravel !== undefined && object.timeTravel !== null)
      ? TimeTravel.fromPartial(object.timeTravel)
      : undefined;
    message.protocolVersionOverride =
      (object.protocolVersionOverride !== undefined && object.protocolVersionOverride !== null)
        ? ProtocolVersionOverride.fromPartial(object.protocolVersionOverride)
        : undefined;
    message.patchVersion = object.patchVersion ?? "";
    return message;
  },
};

export type WebAuthenticationDefinition = typeof WebAuthenticationDefinition;
export const WebAuthenticationDefinition = {
  name: "WebAuthentication",
  fullName: "santiago.web.authentication.WebAuthentication",
  methods: {
    viaAuthCode: {
      name: "viaAuthCode",
      requestType: AuthCodeAuthentication,
      requestStream: false,
      responseType: AuthenticationResponse,
      responseStream: false,
      options: {},
    },
    logout: {
      name: "logout",
      requestType: Empty,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface WebAuthenticationServiceImplementation<CallContextExt = {}> {
  viaAuthCode(
    request: AuthCodeAuthentication,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AuthenticationResponse>>;
  logout(request: Empty, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
}

export interface WebAuthenticationClient<CallOptionsExt = {}> {
  viaAuthCode(
    request: DeepPartial<AuthCodeAuthentication>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AuthenticationResponse>;
  logout(request: DeepPartial<Empty>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
